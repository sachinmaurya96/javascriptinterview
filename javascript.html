<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Hanuman:wght@400;700&family=Poppins:wght@400;500;600&display=swap"
        rel="stylesheet">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Saira+Semi+Condensed&display=swap" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC" crossorigin="anonymous">
        <link rel="stylesheet" href="style.css">
    <title>javascript</title>
</head>

<body>
    <button id="btn">nav</button>
    <div class="container-fluid main">
        <div class="sidebar">

            <div id="side"></div>
        </div>
        <div class="article container">
            <div data-scroll-id="0" data-scroll-identifier="each-article-section" id="freshers">
                <h2>JavaScript Interview Questions for Freshers</h2>

                <section class="ibpage-article-header" id="different-data-types-present-in-javascript">
                    <h3>1. What are the different data types present in javascript?</h3>
                    <article class="ibpage-article">
                        <p>To know the type of a JavaScript variable, we can use the <strong>typeof </strong>operator.
                        </p>
                        <p><strong>1. Primitive types</strong></p>
                        <p><strong>String </strong>- It represents a series of characters and is written with quotes. A
                            string
                            can be represented using a single or a double quote.</p>
                        <p>Example :</p>
                        <pre><code class="language-javascript hljs"><span class="hljs-keyword">var</span> str = <span class="hljs-string">"Vivek Singh Bisht"</span>; <span class="hljs-comment">//using double quotes</span>
    <span class="hljs-keyword">var</span> str2 = <span class="hljs-string">'John Doe'</span>; <span class="hljs-comment">//using single quotes</span></code></pre>
                        <ul>
                            <li>
                                <strong>Number </strong>- It represents a number and can be written with or without
                                decimals.
                            </li>
                        </ul>
                        <p>Example :</p>
                        <pre><code class="language-javascript hljs"><span class="hljs-keyword">var</span> x = <span class="hljs-number">3</span>; <span class="hljs-comment">//without decimal</span>
    <span class="hljs-keyword">var</span> y = <span class="hljs-number">3.6</span>; <span class="hljs-comment">//with decimal</span></code></pre>
                        <ul>
                            <li>
                                <strong>BigInt </strong>- This data type is used to store numbers which are above the
                                limitation
                                of the Number data type. It can store large integers and is represented by adding “n” to
                                an
                                integer literal.
                            </li>
                        </ul>
                        <p>Example :</p>
                        <pre><code class="language-javascript hljs"><span class="hljs-keyword">var</span> bigInteger =  <span class="hljs-number">234567890123456789012345678901234567890</span>;</code></pre>
                        <ul>
                            <li>
                                <strong>Boolean </strong>- It represents a logical entity and can have only two values :
                                true or
                                false. Booleans are generally used for conditional testing.
                            </li>
                        </ul>
                        <p>Example :</p>
                        <pre><code class="language-javascript hljs"><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;
    <span class="hljs-keyword">var</span> b =  <span class="hljs-number">3</span>;
    <span class="hljs-keyword">var</span> c =  <span class="hljs-number">2</span>;
    (a == b) <span class="hljs-comment">// returns false</span>
    (a == c) <span class="hljs-comment">//returns true</span></code></pre>
                        <ul>
                            <li>
                                <strong>Undefined </strong>- When a variable is declared but not assigned, it has the
                                value of
                                undefined and it’s type is also undefined.
                            </li>
                        </ul>
                        <p>Example :</p>
                        <pre><code class="language-javascript hljs"><span class="hljs-keyword">var</span> x; <span class="hljs-comment">// value of x is undefined</span>
    <span class="hljs-keyword">var</span> y = <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// we can also set the value of a variable as undefined</span></code></pre>
                        <ul>
                            <li>
                                <strong>Null </strong>- It represents a non-existent or a invalid value.
                            </li>
                        </ul>
                        <p>Example :</p>
                        <pre><code class="language-javascript hljs"><span class="hljs-keyword">var</span> z = <span class="hljs-literal">null</span>;</code></pre>
                        <ul>
                            <li>
                                <strong>Symbol </strong>- It is a new data type introduced in the ES6 version of
                                javascript. It
                                is used to store an anonymous and unique value.
                            </li>
                        </ul>
                        <p>Example :</p>
                        <pre><code class="language-javascript hljs"><span class="hljs-keyword">var</span> symbol1 = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">'symbol'</span>);</code></pre>
                        <ul>
                            <li>typeof <strong>of primitive types </strong>:</li>
                        </ul>
                        <pre><code class="language-javascript hljs"><span class="hljs-keyword">typeof</span> <span class="hljs-string">"John Doe"</span> <span class="hljs-comment">// Returns "string"</span>
    <span class="hljs-keyword">typeof</span> <span class="hljs-number">3.14</span> <span class="hljs-comment">// Returns "number"</span>
    <span class="hljs-keyword">typeof</span> <span class="hljs-literal">true</span> <span class="hljs-comment">// Returns "boolean"</span>
    <span class="hljs-keyword">typeof</span> <span class="hljs-number">234567890123456789012345678901234567890n</span> <span class="hljs-comment">// Returns bigint</span>
    <span class="hljs-keyword">typeof</span> <span class="hljs-literal">undefined</span> <span class="hljs-comment">// Returns "undefined"</span>
    <span class="hljs-keyword">typeof</span> <span class="hljs-literal">null</span> <span class="hljs-comment">// Returns "object" (kind of a bug in JavaScript)</span>
    <span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">'symbol'</span>) <span class="hljs-comment">// Returns Symbol</span></code></pre>
                        <p><strong>2. Non-primitive types</strong></p>
                        <ul>
                            <li>Primitive data types can store only a single value. To store multiple and complex
                                values,
                                non-primitive data types are used.</li>
                            <li>Object - Used to store collection of data.</li>
                            <li>Example:</li>
                        </ul>
                        <pre><code class="language-javascript hljs"><span class="hljs-comment">// Collection of data in key-value pairs</span>
    
    <span class="hljs-keyword">var</span> obj1 = {
       <span class="hljs-attr">x</span>:  <span class="hljs-number">43</span>,
       <span class="hljs-attr">y</span>:  <span class="hljs-string">"Hello world!"</span>,
       <span class="hljs-attr">z</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
          <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.x;
       }
    }
          
    <span class="hljs-comment">// Collection of data as an ordered list</span>
         
    <span class="hljs-keyword">var</span> array1 = [<span class="hljs-number">5</span>, <span class="hljs-string">"Hello"</span>, <span class="hljs-literal">true</span>, <span class="hljs-number">4.1</span>]; </code></pre>
                        <blockquote>
                            <h4><strong>Note- It is important to remember that any data type that is not a primitive
                                    data type,
                                    is of Object type in javascript.</strong></h4>
                        </blockquote>
                    </article>
                    <div class="ibpage-article-problems" id="1">


                    </div>
                </section>
                <section class="ibpage-article-header" id="explain-hoisting">
                    <h3>2. Explain Hoisting in javascript.</h3>
                    <article class="ibpage-article">
                        <p>Hoisting is the default behaviour of javascript where all the variable and function
                            declarations are
                            moved on top.</p>
                        <figure class="image image_resized" style="width:50%;"><img
                                data-src="https://d3n0h9tb65y8q.cloudfront.net/public_assets/assets/000/003/406/original/Hoisting.png?1654851517"
                                class=""
                                src="https://d3n0h9tb65y8q.cloudfront.net/public_assets/assets/000/003/406/original/Hoisting.png?1654851517">
                        </figure>
                        <p>This means that irrespective of where the variables and functions are declared, they are
                            moved on top
                            of the scope. The scope can be both local and global.<br><br><strong>Example 1:</strong></p>
                        <pre><code class="language-javascript hljs">hoistedVariable = <span class="hljs-number">3</span>;
    <span class="hljs-built_in">console</span>.log(hoistedVariable); <span class="hljs-comment">// outputs 3 even when the variable is declared after it is initialized	</span>
    <span class="hljs-keyword">var</span> hoistedVariable;</code></pre>
                        <p><strong>Example 2:</strong></p>
                        <pre><code class="language-javascript hljs">hoistedFunction();  <span class="hljs-comment">// Outputs " Hello world! " even when the function is declared after calling</span>
    
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hoistedFunction</span>(<span class="hljs-params"></span>)</span>{ 
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">" Hello world! "</span>);
    }&nbsp;</code></pre>
                        <p><strong>Example 3:</strong></p>
                        <pre><code class="language-javascript hljs"><span class="hljs-comment">// Hoisting takes place in the local scope as well</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doSomething</span>(<span class="hljs-params"></span>)</span>{
      x = <span class="hljs-number">33</span>;
      <span class="hljs-built_in">console</span>.log(x);
      <span class="hljs-keyword">var</span> x;
    }&nbsp;</code></pre>
                        <p>doSomething(); // Outputs 33 since the local variable “x” is hoisted inside the local scope
                        </p>
                        <blockquote>
                            <h4><strong>Note - Variable initializations are not hoisted, only variable declarations are
                                    hoisted:</strong></h4>
                        </blockquote>
                        <pre><code class="language-javascript hljs"><span class="hljs-keyword">var</span> x;
    <span class="hljs-built_in">console</span>.log(x); <span class="hljs-comment">// Outputs "undefined" since the initialization of "x" is not hoisted</span>
    x = <span class="hljs-number">23</span>;</code></pre>
                        <blockquote>
                            <h4><strong>Note - To avoid hoisting, you can run javascript in strict mode by using “use
                                    strict” on
                                    top of the code:</strong></h4>
                        </blockquote>
                        <pre><code class="language-javascript hljs"><span class="hljs-meta">"use strict"</span>;
    x = <span class="hljs-number">23</span>; <span class="hljs-comment">// Gives an error since 'x' is not declared</span>
    <span class="hljs-keyword">var</span> x; </code></pre>
                    </article>
                    <div class="ibpage-article-problems" id="2">


                    </div>
                </section>
                <section class="ibpage-article-header" id="debugger">
                    <h3>3. Why do we use the word “debugger” in javascript?</h3>
                    <article class="ibpage-article">
                        <p>The debugger for the browser must be activated in order to debug the code. Built-in debuggers
                            may be
                            switched on and off, requiring the user to report faults. The remaining section of the code
                            should
                            stop execution before moving on to the next line while debugging.</p>
                    </article>
                    <div class="ibpage-article-problems" id="3">


                    </div>
                </section>

                <section class="ibpage-article-header" id="difference-between-and-operators">
                    <h3>4. Difference between “ == “ and “ === “ operators.</h3>
                    <article class="ibpage-article">
                        <p>Both are comparison operators. The difference between both the operators is that “==” is used
                            to
                            compare values whereas, “ === “ is used to compare both values and types.</p>
                        <p><strong>Example:</strong></p>
                        <pre><code class="language-javascript hljs"><span class="hljs-keyword">var</span> x = <span class="hljs-number">2</span>;
    <span class="hljs-keyword">var</span> y = <span class="hljs-string">"2"</span>;
    (x == y)  <span class="hljs-comment">// Returns true since the value of both x and y is the same</span>
    (x === y) <span class="hljs-comment">// Returns false since the typeof x is "number" and typeof y is "string"</span></code></pre>
                    </article>
                    <div class="ibpage-article-problems" id="4">


                    </div>
                </section>
                <section class="ibpage-article-header" id="difference-between-var-and-let-keyword-in-javascript">
                    <h3>5. Difference between var and let keyword in javascript.</h3>
                    <article class="ibpage-article">
                        <p>Some differences are<strong>&nbsp;</strong></p>
                        <ol>
                            <li>From the very beginning, the 'var' keyword was used in JavaScript programming
                                <strong>whereas
                                    the keyword </strong>'let' was just added in 2015.</li>
                            <li>The keyword 'Var' has a function scope. Anywhere in the function, the variable specified
                                using
                                var is accessible but in ‘let’ the scope of a variable declared with the 'let' keyword
                                is
                                limited to the block in which it is declared. Let's start with a Block Scope.</li>
                            <li>In ECMAScript 2015, let and const are hoisted but not initialized. Referencing the
                                variable in
                                the block before the variable declaration results in a ReferenceError because the
                                variable is in
                                a "temporal dead zone" from the start of the block until the declaration is processed.
                            </li>
                        </ol>
                    </article>
                    <div class="ibpage-article-problems" id="5">



                    </div>
                </section>
                <section class="ibpage-article-header" id="implicit-type-coercion">
                    <h3>6. Explain Implicit Type Coercion in javascript.</h3>
                    <article class="ibpage-article">
                        <p>Implicit type coercion in javascript is the automatic conversion of value from one data type
                            to
                            another. It takes place when the operands of an expression are of different data types.</p>
                        <ul>
                            <li><strong>String coercion</strong></li>
                        </ul>
                        <p>String coercion takes place while using the ‘ + ‘ operator. When a number is added to a
                            string, the
                            number type is always converted to the string type.</p>
                        <p>Example 1:</p>
                        <pre><code class="language-javascript hljs"><span class="hljs-keyword">var</span> x = <span class="hljs-number">3</span>;
    <span class="hljs-keyword">var</span> y = <span class="hljs-string">"3"</span>;
    x + y <span class="hljs-comment">// Returns "33" </span></code></pre>
                        <p>Example 2:</p>
                        <pre><code class="language-javascript hljs"><span class="hljs-keyword">var</span> x = <span class="hljs-number">24</span>;
    <span class="hljs-keyword">var</span> y = <span class="hljs-string">"Hello"</span>;
    x + y   <span class="hljs-comment">// Returns "24Hello";&nbsp;</span></code></pre>
                        <blockquote>
                            <h4>Note - ‘ + ‘ operator when used to add two numbers, outputs a number. The same ‘ + ‘
                                operator
                                when used to add two strings, outputs the concatenated string:</h4>
                        </blockquote>
                        <pre><code class="language-javascript hljs"><span class="hljs-keyword">var</span> name = <span class="hljs-string">"Vivek"</span>;
    <span class="hljs-keyword">var</span> surname = <span class="hljs-string">" Bisht"</span>;
    name + surname     <span class="hljs-comment">// Returns "Vivek Bisht"&nbsp;</span></code></pre>
                        <p>Let’s understand both the examples where we have added a number to a string,</p>
                        <p>When JavaScript sees that the operands of the expression x + y are of different types ( one
                            being a
                            number type and the other being a string type ), it converts the number type to the string
                            type and
                            then performs the operation. Since after conversion, both the variables are of string type,
                            the ‘ +
                            ‘ operator outputs the concatenated string “33” in the first example and “24Hello” in the
                            second
                            example.</p>
                        <blockquote>
                            <h4>Note - Type coercion also takes place when using the ‘ - ‘ operator, but the difference
                                while
                                using ‘ - ‘ operator is that, a string is converted to a number and then subtraction
                                takes
                                place.</h4>
                        </blockquote>
                        <pre><code class="language-javascript hljs"><span class="hljs-keyword">var</span> x = <span class="hljs-number">3</span>;
    Var y = <span class="hljs-string">"3"</span>;
    x - y    <span class="hljs-comment">//Returns 0 since the variable y (string type) is converted to a number type</span></code></pre>
                        <ul>
                            <li><strong>Boolean Coercion</strong></li>
                        </ul>
                        <p>Boolean coercion takes place when using logical operators, ternary operators, if statements,
                            and loop
                            checks. To understand boolean coercion in if statements and operators, we need to understand
                            truthy
                            and falsy values.<br><br>Truthy values are those which will be converted (coerced) to
                            <strong>true</strong>. Falsy values are those which will be converted to
                            <strong>false</strong>.<br><br>All values except <strong>false, 0, 0n, -0, “”, null,
                                undefined, and
                                NaN </strong>are truthy values.
                        </p>
                        <p><strong>If statements:</strong></p>
                        <p>Example:</p>
                        <pre><code class="language-javascript hljs"><span class="hljs-keyword">var</span> x = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">var</span> y = <span class="hljs-number">23</span>;
            
    <span class="hljs-keyword">if</span>(x) { <span class="hljs-built_in">console</span>.log(x) }   <span class="hljs-comment">// The code inside this block will not run since the value of x is 0(Falsy)  </span>
            
    <span class="hljs-keyword">if</span>(y) { <span class="hljs-built_in">console</span>.log(y) }    <span class="hljs-comment">// The code inside this block will run since the value of y is 23 (Truthy)</span></code></pre>
                        <ul>
                            <li><strong>Logical operators:</strong></li>
                        </ul>
                        <p>Logical operators in javascript, unlike operators in other programming languages, <strong>do
                                not
                                return true or false. They always return one of the operands.</strong><br><br><strong>OR
                                ( | | )
                                operator </strong>- If the first value is truthy, then the first value is returned.
                            Otherwise,
                            always the second value gets returned.<br><br><strong>AND ( &amp;&amp; ) operator </strong>-
                            If both
                            the values are truthy, always the second value is returned. If the first value is falsy then
                            the
                            first value is returned or if the second value is falsy then the second value is
                            returned.<br><br>Example:</p>
                        <pre><code class="language-javascript hljs"><span class="hljs-keyword">var</span> x = <span class="hljs-number">220</span>;
    <span class="hljs-keyword">var</span> y = <span class="hljs-string">"Hello"</span>;
    <span class="hljs-keyword">var</span> z = <span class="hljs-literal">undefined</span>;
            
    x | | y    <span class="hljs-comment">// Returns 220 since the first value is truthy</span>
            
    x | | z   <span class="hljs-comment">// Returns 220 since the first value is truthy</span>
            
    x &amp;&amp; y    <span class="hljs-comment">// Returns "Hello" since both the values are truthy</span>
            
    y &amp;&amp; z   <span class="hljs-comment">// Returns undefined since the second value is falsy</span>
            
    <span class="hljs-keyword">if</span>( x &amp;&amp; y ){ 
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Code runs"</span> ); <span class="hljs-comment">// This block runs because x &amp;&amp; y returns "Hello" (Truthy)</span>
    }   
            
    <span class="hljs-keyword">if</span>( x || z ){
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Code runs"</span>);  <span class="hljs-comment">// This block runs because x || y returns 220(Truthy)</span>
    }</code></pre>
                        <ul>
                            <li><strong>Equality Coercion</strong></li>
                        </ul>
                        <p>Equality coercion takes place when using ‘ == ‘ operator. As we have stated
                            before<br><br><strong>The
                                ‘ == ‘ operator compares values and not types.</strong><br><br>While the above statement
                            is a
                            simple way to explain == operator, it’s not completely true<br><br>The reality is that while
                            using
                            the ‘==’ operator, coercion takes place.<br><br>The ‘==’ operator, converts both the
                            operands to the
                            same type and then compares them.<br><br>Example:</p>
                        <pre><code class="language-javascript hljs"><span class="hljs-keyword">var</span> a = <span class="hljs-number">12</span>;
    <span class="hljs-keyword">var</span> b = <span class="hljs-string">"12"</span>;
    a == b <span class="hljs-comment">// Returns true because both 'a' and 'b' are converted to the same type and then compared. Hence the operands are equal.</span></code></pre>
                        <p>Coercion does not take place when using the ‘===’ operator. Both operands are not converted
                            to the
                            same type in the case of ‘===’ operator.</p>
                        <p>Example:</p>
                        <pre><code class="language-javascript hljs"><span class="hljs-keyword">var</span> a = <span class="hljs-number">226</span>;
    <span class="hljs-keyword">var</span> b = <span class="hljs-string">"226"</span>;
    
    a === b <span class="hljs-comment">// Returns false because coercion does not take place and the  operands are of different types. Hence they are not equal.&nbsp;</span></code></pre>
                    </article>
                    <div class="ibpage-article-problems" id="6">


                    </div>
                </section>
                <section class="ibpage-article-header"
                    id="is-javascript-a-statically-typed-or-a-dynamically-typed-language">
                    <h3>7. Is javascript a statically typed or a dynamically typed language?</h3>
                    <article class="ibpage-article">
                        <p>JavaScript is a dynamically typed language. In a dynamically typed language, the type of a
                            variable
                            is checked during <strong>run-time </strong>in contrast to a statically typed language,
                            where the
                            type of a variable is checked during <strong>compile-time.</strong></p>
                        <figure class="image image_resized" style="width:50%;"><img
                                data-src="https://d3n0h9tb65y8q.cloudfront.net/public_assets/assets/000/003/407/original/static_vs_dynamic.png?1654852333"
                                class=""
                                src="https://d3n0h9tb65y8q.cloudfront.net/public_assets/assets/000/003/407/original/static_vs_dynamic.png?1654852333">
                        </figure>
                        <p>Since javascript is a loosely(dynamically) typed language, variables in JS are not associated
                            with
                            any type. A variable can hold the value of any data type.</p>
                        <p>For example, a variable that is assigned a number type can be converted to a string type:</p>
                        <pre><code class="language-javascript hljs"><span class="hljs-keyword">var</span> a = <span class="hljs-number">23</span>;
    <span class="hljs-keyword">var</span> a = <span class="hljs-string">"Hello World!"</span>;</code></pre>
                    </article>
                    <div class="ibpage-article-problems" id="7">


                    </div>
                </section>
                <section class="ibpage-article-header" id="nan-property">
                    <h3>8. What is NaN property in JavaScript?</h3>
                    <article class="ibpage-article">
                        <p>NaN property represents the <strong>“Not-a-Number” </strong>value. It indicates a value that
                            is not a
                            legal number.</p>
                        <p><strong>typeof </strong>of NaN will return a <strong>Number</strong>.</p>
                        <p>To check if a value is NaN, we use the <strong>isNaN() </strong>function,</p>
                        <blockquote>
                            <h4>Note- isNaN() function converts the given value to a Number type, and then equates to
                                NaN.</h4>
                        </blockquote>
                        <pre><code class="language-javascript hljs"><span class="hljs-built_in">isNaN</span>(<span class="hljs-string">"Hello"</span>)  <span class="hljs-comment">// Returns true</span>
    <span class="hljs-built_in">isNaN</span>(<span class="hljs-number">345</span>)   <span class="hljs-comment">// Returns false</span>
    <span class="hljs-built_in">isNaN</span>(<span class="hljs-string">'1'</span>)  <span class="hljs-comment">// Returns false, since '1' is converted to Number type which results in 0 ( a number) </span>
    <span class="hljs-built_in">isNaN</span>(<span class="hljs-literal">true</span>) <span class="hljs-comment">// Returns false, since true converted to Number type results in 1 ( a number)</span>
    <span class="hljs-built_in">isNaN</span>(<span class="hljs-literal">false</span>) <span class="hljs-comment">// Returns false</span>
    <span class="hljs-built_in">isNaN</span>(<span class="hljs-literal">undefined</span>) <span class="hljs-comment">// Returns true</span></code></pre>
                    </article>
                    <div class="ibpage-article-problems" id="8">


                    </div>
                </section>
                <section class="ibpage-article-header" id="explain-passed-by-value-and-passed-by-reference">
                    <h3>9. Explain passed by value and passed by reference.</h3>
                    <article class="ibpage-article">
                        <p><strong>In JavaScript, primitive data types are passed by value and non-primitive data types
                                are
                                passed by reference.</strong><br><br>For understanding passed by value and passed by
                            reference,
                            we need to understand what happens when we create a variable and assign a value to it,</p>
                        <pre><code class="language-javascript hljs"><span class="hljs-keyword">var</span> x = <span class="hljs-number">2</span>;</code></pre>
                        <p>In the above example, we created a variable x and assigned it a value of “2”. In the
                            background, the
                            “=” (assign operator) allocates some space in the memory, stores the value “2” and returns
                            the
                            location of the allocated memory space. Therefore, the variable x in the above code points
                            to the
                            location of the memory space instead of pointing to the value 2 directly.</p>
                        <p>Assign operator behaves differently when dealing with primitive and non-primitive data
                            types,<br><br><strong>Assign operator dealing with primitive types:</strong></p>
                        <figure class="image image_resized" style="width:75%;"><img
                                data-src="https://d3n0h9tb65y8q.cloudfront.net/public_assets/assets/000/003/408/original/Assign_operator_dealing_with_primitive_types.png?1654852446"
                                class=""
                                src="https://d3n0h9tb65y8q.cloudfront.net/public_assets/assets/000/003/408/original/Assign_operator_dealing_with_primitive_types.png?1654852446">
                        </figure>
                        <pre><code class="language-javascript hljs"><span class="hljs-keyword">var</span> y = <span class="hljs-number">234</span>;
    <span class="hljs-keyword">var</span> z = y;</code></pre>
                        <p>In the above example, the assign operator knows that the value assigned to y is a primitive
                            type
                            (number type in this case), so when the second line code executes, where the value of y is
                            assigned
                            to z, the assign operator takes the value of y (234) and allocates a new space in the memory
                            and
                            returns the address. Therefore, variable z is not pointing to the location of variable y,
                            instead,
                            it is pointing to a new location in the memory.</p>
                        <pre><code class="language-javascript hljs"><span class="hljs-keyword">var</span> y = #<span class="hljs-number">8454</span>; <span class="hljs-comment">// y pointing to address of the value 234</span>
    
    <span class="hljs-keyword">var</span> z = y; 
         
    <span class="hljs-keyword">var</span> z = #<span class="hljs-number">5411</span>; <span class="hljs-comment">// z pointing to a completely new address of the value 234</span>
         
    <span class="hljs-comment">// Changing the value of y</span>
    y = <span class="hljs-number">23</span>;
    <span class="hljs-built_in">console</span>.log(z);  <span class="hljs-comment">// Returns 234, since z points to a new address in the memory so changes in y will not effect z</span></code></pre>
                        <p>From the above example, we can see that primitive data types when passed to another variable,
                            are
                            passed by value. Instead of just assigning the same address to another variable, the value
                            is passed
                            and new space of memory is created.<br><br><strong>Assign operator dealing with
                                non-primitive
                                types:</strong></p>
                        <figure class="image image_resized" style="width:75%;"><img
                                data-src="https://d3n0h9tb65y8q.cloudfront.net/public_assets/assets/000/003/410/original/Assign_operator_dealing_with_non-primitive_types.png?1654852531"
                                class=""
                                src="https://d3n0h9tb65y8q.cloudfront.net/public_assets/assets/000/003/410/original/Assign_operator_dealing_with_non-primitive_types.png?1654852531">
                        </figure>
                        <pre><code class="language-javascript hljs"><span class="hljs-keyword">var</span> obj = { <span class="hljs-attr">name</span>: <span class="hljs-string">"Vivek"</span>, <span class="hljs-attr">surname</span>: <span class="hljs-string">"Bisht"</span> };
    <span class="hljs-keyword">var</span> obj2 = obj;</code></pre>
                        <p>In the above example, the assign operator directly passes the location of the variable obj to
                            the
                            variable obj2. In other words, the reference of the variable obj is passed to the variable
                            obj2.</p>
                        <pre><code class="language-javascript hljs"><span class="hljs-keyword">var</span> obj = #<span class="hljs-number">8711</span>;  <span class="hljs-comment">// obj pointing to address of { name: "Vivek", surname: "Bisht" }</span>
    <span class="hljs-keyword">var</span> obj2 = obj;
        
    <span class="hljs-keyword">var</span> obj2 = #<span class="hljs-number">8711</span>; <span class="hljs-comment">// obj2 pointing to the same address </span>
    
    <span class="hljs-comment">// changing the value of obj1</span>
            
    obj1.name = <span class="hljs-string">"Akki"</span>;
    <span class="hljs-built_in">console</span>.log(obj2);
            
    <span class="hljs-comment">// Returns {name:"Akki", surname:"Bisht"} since both the variables are pointing to the same address.</span></code></pre>
                        <p>From the above example, we can see that while passing non-primitive data types, the assign
                            operator
                            directly passes the address (reference).<br><br>Therefore, non-primitive data types are
                            always
                            <strong>passed by reference.</strong>
                        </p>
                    </article>
                    <div class="ibpage-article-problems" id="9">


                    </div>
                </section>
                <section class="ibpage-article-header" id="immediately-invoked-function">
                    <h3>10. What is an Immediately Invoked Function in JavaScript?</h3>
                    <article class="ibpage-article">
                        <p><strong>An Immediately Invoked Function ( known as IIFE and pronounced as IIFY) is a function
                                that
                                runs as soon as it is defined.</strong></p>
                        <p>Syntax of IIFE :</p>
                        <pre><code class="language-javascript hljs">(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{ 
      <span class="hljs-comment">// Do something;</span>
    })();</code></pre>
                        <p>To understand IIFE, we need to understand the two sets of parentheses that are added while
                            creating
                            an IIFE :<br><br>The first set of parenthesis:</p>
                        <pre><code class="language-javascript hljs">(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)</span>{
       <span class="hljs-comment">//Do something;</span>
    })</code></pre>
                        <p>While executing javascript code, whenever the compiler sees the word “function”, it assumes
                            that we
                            are declaring a function in the code. Therefore, if we do not use the first set of
                            parentheses, the
                            compiler throws an error because it thinks we are declaring a function, and by the syntax of
                            declaring a function, a function should always have a name.</p>
                        <pre><code class="language-javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-comment">//Do something;</span>
    }
    <span class="hljs-comment">// Compiler gives an error since the syntax of declaring a function is wrong in the code above.</span></code></pre>
                        <p>To remove this error, we add the first set of parenthesis that tells the compiler that the
                            function
                            is not a function declaration, instead, it’s a function expression.<br><br>The second set of
                            parenthesis:</p>
                        <pre><code class="language-javascript hljs">(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)</span>{
      <span class="hljs-comment">//Do something;</span>
    })();</code></pre>
                        <p>From the definition of an IIFE, we know that our code should run as soon as it is defined. A
                            function
                            runs only when it is invoked. If we do not invoke the function, the function declaration is
                            returned:</p>
                        <pre><code class="language-javascript hljs">(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)</span>{
      <span class="hljs-comment">// Do something;</span>
    })
    
    <span class="hljs-comment">// Returns the function declaration</span></code></pre>
                        <p><strong>Therefore to invoke the function, we use the second set of parenthesis.</strong></p>
                    </article>
                    <div class="ibpage-article-problems" id="10">


                    </div>
                </section>
                <section class="ibpage-article-header" id="script-mode-and-its-characteristics">
                    <h3>11. What do you mean by strict mode in javascript and characteristics of javascript strict-mode?
                    </h3>
                    <article class="ibpage-article">
                        <p>In ECMAScript 5, a new feature called JavaScript Strict Mode allows you to write a code or a
                            function
                            in a "strict" operational environment. In most cases, this language is 'not particularly
                            severe'
                            when it comes to throwing errors. In 'Strict mode,' however, all forms of errors, including
                            silent
                            errors, will be thrown. As a result, debugging becomes a lot simpler.&nbsp; Thus
                            programmer's
                            chances of making an error are lowered.</p>
                        <p>Characteristics of strict mode in javascript</p>
                        <ol>
                            <li>Duplicate arguments are not allowed by developers.</li>
                            <li>In strict mode, you won't be able to use the JavaScript keyword as a parameter or
                                function name.
                            </li>
                            <li>The 'use strict' keyword is used to define strict mode at the start of the script.
                                Strict mode
                                is supported by all browsers.</li>
                            <li>Engineers will not be allowed to create global variables in 'Strict Mode.</li>
                        </ol>
                    </article>
                    <div class="ibpage-article-problems" id="11">


                    </div>
                </section>
                <section class="ibpage-article-header" id="explain-higher-order-functions-in-javascript">
                    <h3>12. Explain Higher Order Functions in javascript.</h3>
                    <article class="ibpage-article">
                        <p><strong>Functions that operate on other functions, either by taking them as arguments or by
                                returning
                                them, are called higher-order functions.</strong><br><br>Higher-order functions are a
                            result of
                            functions being <strong>first-class citizens </strong>in javascript.</p>
                        <p>Examples of higher-order functions:</p>
                        <pre><code class="language-javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">higherOrder</span>(<span class="hljs-params">fn</span>) </span>{
      fn();
    }
       
    higherOrder(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Hello world"</span>) }); &nbsp;</code></pre>
                        <pre><code class="language-javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">higherOrder2</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-string">"Do something"</span>;
      }
    }      
    <span class="hljs-keyword">var</span> x = higherOrder2();
    x()   <span class="hljs-comment">// Returns "Do something"</span></code></pre>
                    </article>
                    <div class="ibpage-article-problems" id="12">


                    </div>
                </section>
                <section class="ibpage-article-header" id="this-keyword">
                    <h3>13. Explain “this” keyword.</h3>
                    <article class="ibpage-article">
                        <p><strong>The “this” keyword refers to the object that the function is a property
                                of.</strong><br><br><strong>The value of the “this” keyword will always depend on the
                                object
                                that is invoking the function.\</strong></p>
                        <p>Confused? Let’s understand the above statements by examples:</p>
                        <pre><code class="language-javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doSomething</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>);
    }
       
    doSomething();</code></pre>
                        <p>What do you think the output of the above code will be?</p>
                        <blockquote>
                            <p>Note - Observe the line where we are invoking the function.</p>
                        </blockquote>
                        <p>Check the definition again:</p>
                        <blockquote>
                            <h4><strong>The “this” keyword refers to the object that the function is a property
                                    of.</strong>
                            </h4>
                        </blockquote>
                        <p>In the above code, the function is a property of which object?</p>
                        <p>Since the function is invoked in the global context, <strong>the function is a property of
                                the global
                                object.</strong></p>
                        <p>Therefore, the output of the above code will be <strong>the global object. </strong>Since we
                            ran the
                            above code inside the browser, the global object is <strong>the window object.</strong></p>
                        <p>Example 2:</p>
                        <pre><code class="language-javascript hljs"><span class="hljs-keyword">var</span> obj = {
        <span class="hljs-attr">name</span>:  <span class="hljs-string">"vivek"</span>,
        <span class="hljs-attr">getName</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name);
      }
    }
       
    obj.getName();</code></pre>
                        <p>In the above code, at the time of invocation, the getName function is a property of the
                            object
                            <strong>obj </strong>, therefore, <strong>this </strong>keyword will refer to the object
                            <strong>obj</strong>, and hence the output will be “vivek”.
                        </p>
                        <p>Example 3:</p>
                        <pre><code class="language-javascript hljs"> <span class="hljs-keyword">var</span> obj = {
        <span class="hljs-attr">name</span>:  <span class="hljs-string">"vivek"</span>,
        <span class="hljs-attr">getName</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name);
      }
         
    }
           
    <span class="hljs-keyword">var</span> getName = obj.getName;
           
    <span class="hljs-keyword">var</span> obj2 = {<span class="hljs-attr">name</span>:<span class="hljs-string">"akshay"</span>, getName };
    obj2.getName();</code></pre>
                        <p>Can you guess the output here?</p>
                        <p>The output will be “akshay”.</p>
                        <p>Although the getName function is declared inside the object <strong>obj</strong>, at the time
                            of
                            invocation, getName() is a property of <strong>obj2</strong>, therefore the “this” keyword
                            will
                            refer to <strong>obj2</strong>.</p>
                        <p>The silly way to understand the “<strong>this” </strong>keyword is, whenever the function is
                            invoked,
                            check the object before the <strong>dot</strong>. The value of <strong>this </strong>.
                            keyword will
                            always be the object before the <strong>dot</strong>.</p>
                        <p>If there is no object before the dot-like in example1, the value of this keyword will be the
                            global
                            object.</p>
                        <p>Example 4:</p>
                        <pre><code class="language-javascript hljs"><span class="hljs-keyword">var</span> obj1 = {
        <span class="hljs-attr">address</span> : <span class="hljs-string">"Mumbai,India"</span>,
        <span class="hljs-attr">getAddress</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.address); 
      }
    }
       
    <span class="hljs-keyword">var</span> getAddress = obj1.getAddress;
    <span class="hljs-keyword">var</span> obj2 = {<span class="hljs-attr">name</span>:<span class="hljs-string">"akshay"</span>};
    obj2.getAddress();    </code></pre>
                        <p>Can you guess the output?</p>
                        <p><strong>The output will be an error.</strong></p>
                        <p>Although in the code above, this keyword refers to the object <strong>obj2</strong>, obj2
                            does not
                            have the property “address”‘, hence the getAddress function throws an error.</p>
                    </article>
                    <div class="ibpage-article-problems" id="13">


                    </div>
                </section>
                <section class="ibpage-article-header" id="self-invoking-functions">
                    <h3>14. What do you mean by Self Invoking Functions?</h3>
                    <article class="ibpage-article">
                        <p>Without being requested, a self-invoking expression is automatically invoked (initiated). If
                            a
                            function expression is followed by (), it will execute automatically. A function declaration
                            cannot
                            be invoked by itself.</p>
                        <p>Normally, we declare a function and call it, however, anonymous functions may be used to run
                            a
                            function automatically when it is described and will not be called again. And there is no
                            name for
                            these kinds of functions.</p>
                    </article>
                    <div class="ibpage-article-problems" id="14">


                    </div>
                </section>
                <section class="ibpage-article-header" id="call-apply-and-bind-methods">
                    <h3>15. Explain call(), apply() and, bind() methods.</h3>
                    <article class="ibpage-article">
                        <p><strong>1. call():</strong></p>
                        <ul>
                            <li>It’s a predefined method in javascript.</li>
                            <li>This method invokes a method (function) by specifying the owner object.</li>
                            <li>Example 1:</li>
                        </ul>
                        <pre><code class="language-javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sayHello</span>(<span class="hljs-params"></span>)</span>{
      <span class="hljs-keyword">return</span> <span class="hljs-string">"Hello "</span> + <span class="hljs-built_in">this</span>.name;
    }
            
    <span class="hljs-keyword">var</span> obj = {<span class="hljs-attr">name</span>: <span class="hljs-string">"Sandy"</span>};
            
    sayHello.call(obj);
            
    <span class="hljs-comment">// Returns "Hello Sandy"	</span></code></pre>
                        <ul>
                            <li>call() method allows an object to use the method (function) of another object.</li>
                            <li>Example 2:</li>
                        </ul>
                        <pre><code class="language-javascript hljs"><span class="hljs-keyword">var</span> person = {
      <span class="hljs-attr">age</span>: <span class="hljs-number">23</span>,
      <span class="hljs-attr">getAge</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.age;
      }
    }        
    <span class="hljs-keyword">var</span> person2 = {<span class="hljs-attr">age</span>:  <span class="hljs-number">54</span>};
    person.getAge.call(person2);      
    <span class="hljs-comment">// Returns 54  </span></code></pre>
                        <ul>
                            <li>call() accepts arguments:</li>
                        </ul>
                        <pre><code class="language-javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">saySomething</span>(<span class="hljs-params">message</span>)</span>{
      <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name + <span class="hljs-string">" is "</span> + message;
    }     
    <span class="hljs-keyword">var</span> person4 = {<span class="hljs-attr">name</span>:  <span class="hljs-string">"John"</span>};     
    saySomething.call(person4, <span class="hljs-string">"awesome"</span>);
    <span class="hljs-comment">// Returns "John is awesome"    </span></code></pre>
                        <p><strong>apply()</strong><br><br>The apply method is similar to the call() method. The only
                            difference
                            is that,<br><br><strong>call() method takes arguments separately whereas, apply() method
                                takes
                                arguments as an array.</strong></p>
                        <pre><code class="language-javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">saySomething</span>(<span class="hljs-params">message</span>)</span>{
      <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name + <span class="hljs-string">" is "</span> + message;
    }        
    <span class="hljs-keyword">var</span> person4 = {<span class="hljs-attr">name</span>:  <span class="hljs-string">"John"</span>};
    saySomething.apply(person4, [<span class="hljs-string">"awesome"</span>]);</code></pre>
                        <p><strong>2. bind():</strong></p>
                        <ul>
                            <li>This method returns a new function, where the value of <strong>“this” </strong>keyword
                                will be
                                bound to the owner object, which is provided as a parameter.</li>
                            <li>Example with arguments:</li>
                        </ul>
                        <pre><code class="language-javascript hljs"><span class="hljs-keyword">var</span> bikeDetails = {
        <span class="hljs-attr">displayDetails</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">registrationNumber,brandName</span>)</span>{
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name+ <span class="hljs-string">" , "</span>+ <span class="hljs-string">"bike details: "</span>+ registrationNumber + <span class="hljs-string">" , "</span> + brandName;
      }
    }
       
    <span class="hljs-keyword">var</span> person1 = {<span class="hljs-attr">name</span>:  <span class="hljs-string">"Vivek"</span>};
         
    <span class="hljs-keyword">var</span> detailsOfPerson1 = bikeDetails.displayDetails.bind(person1, <span class="hljs-string">"TS0122"</span>, <span class="hljs-string">"Bullet"</span>);
          
    <span class="hljs-comment">// Binds the displayDetails function to the person1 object</span>
            
          
    detailsOfPerson1();
    <span class="hljs-comment">//Returns Vivek, bike details: TS0122, Bullet</span></code></pre>
                    </article>
                    <div class="ibpage-article-problems" id="15">


                    </div>
                </section>
                <section class="ibpage-article-header" id="difference-between-exec-and-test-methods-in-javascript">
                    <h3>16. What is the difference between exec () and test () methods in javascript?</h3>
                    <article class="ibpage-article">
                        <ul>
                            <li>
                                <strong>test ()</strong> and <strong>exec ()</strong> are RegExp expression methods used
                                in
                                javascript.&nbsp;
                            </li>
                            <li>We'll use <strong>exec ()</strong> to search a string for a specific pattern, and if it
                                finds
                                it, it'll return the pattern directly; else, it'll return an 'empty' result.</li>
                            <li>We will use a<strong> test ()</strong> to find a string for a specific pattern. It will
                                return
                                the Boolean value 'true' on finding the given text otherwise, it will return 'false'.
                            </li>
                        </ul>
                    </article>
                    <div class="ibpage-article-problems" id="16">


                    </div>
                </section>
                <section class="ibpage-article-header" id="currying">
                    <h3>17. What is currying in JavaScript?</h3>
                    <article class="ibpage-article">
                        <p><strong>Currying is an advanced technique to transform a function of arguments n, to n
                                functions of
                                one or fewer arguments.</strong></p>
                        <p>Example of a curried function:</p>
                        <pre><code class="language-javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span> (<span class="hljs-params">a</span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">b</span>)</span>{
        <span class="hljs-keyword">return</span> a + b;
      }
    }
    
    add(<span class="hljs-number">3</span>)(<span class="hljs-number">4</span>)&nbsp;</code></pre>
                        <p>For Example, if we have a function <strong>f(a,b)</strong>, then the function after currying,
                            will be
                            transformed to <strong>f(a)(b).</strong><br><br>By using the currying technique, we do not
                            change
                            the functionality of a function, we just change the way it is invoked.<br><br>Let’s see
                            currying in
                            action:</p>
                        <pre><code class="language-javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">multiply</span>(<span class="hljs-params">a,b</span>)</span>{
      <span class="hljs-keyword">return</span> a*b;
    }
    
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">currying</span>(<span class="hljs-params">fn</span>)</span>{
      <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a</span>)</span>{
        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">b</span>)</span>{
          <span class="hljs-keyword">return</span> fn(a,b);
        }
      }
    }
    
    <span class="hljs-keyword">var</span> curriedMultiply = currying(multiply);
    
    multiply(<span class="hljs-number">4</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">// Returns 12</span>
    
    curriedMultiply(<span class="hljs-number">4</span>)(<span class="hljs-number">3</span>); <span class="hljs-comment">// Also returns 12</span></code></pre>
                        <p>As one can see in the code above, we have transformed the function <strong>multiply(a,b)
                            </strong>to
                            a function <strong>curriedMultiply </strong>, which takes in one parameter at a time.</p>
                    </article>
                    <div class="ibpage-article-problems" id="17">


                    </div>
                </section>
                <section class="ibpage-article-header" id="advantages-of-external-javascript">
                    <h3>18. What are some advantages of using External JavaScript?</h3>
                    <article class="ibpage-article">
                        <p>External JavaScript is the JavaScript Code (script) written in a separate file with the
                            extension.js,
                            and then we link that file inside the &lt;head&gt; or &lt;body&gt; element of the HTML file
                            where
                            the code is to be placed.<strong>&nbsp;</strong></p>
                        <p>Some advantages of external javascript are</p>
                        <ol>
                            <li>It allows web designers and developers to collaborate on HTML and javascript files.</li>
                            <li>We can reuse the code.</li>
                            <li>Code readability is simple in external javascript.</li>
                        </ol>
                    </article>
                    <div class="ibpage-article-problems" id="18">


                    </div>
                </section>
                <section class="ibpage-article-header" id="scope-and-scope-chain-in-javascript">
                    <h3>19. Explain Scope and Scope Chain in javascript.</h3>
                    <article class="ibpage-article">
                        <p>Scope in JS determines the accessibility of variables and functions at various parts of one’s
                            code.<br><br>In general terms, the scope will let us know at a given part of code, what are
                            variables and functions we can or cannot access.<br><br>There are three types of scopes in
                            JS:</p>
                        <ul>
                            <li>Global Scope</li>
                            <li>Local or Function Scope</li>
                            <li>Block Scope</li>
                        </ul>
                        <p><strong>Global Scope: </strong>Variables or functions declared in the global namespace have
                            global
                            scope, which means all the variables and functions having global scope can be accessed from
                            anywhere
                            inside the code.</p>
                        <pre><code class="language-javascript hljs"><span class="hljs-keyword">var</span> globalVariable = <span class="hljs-string">"Hello world"</span>;
    
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sendMessage</span>(<span class="hljs-params"></span>)</span>{
      <span class="hljs-keyword">return</span> globalVariable; <span class="hljs-comment">// can access globalVariable since it's written in global space</span>
    }
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sendMessage2</span>(<span class="hljs-params"></span>)</span>{
      <span class="hljs-keyword">return</span> sendMessage(); <span class="hljs-comment">// Can access sendMessage function since it's written in global space</span>
    }
    sendMessage2();  <span class="hljs-comment">// Returns “Hello world”</span></code></pre>
                        <p><strong>Function Scope: </strong>Any variables or functions declared inside a function have
                            local/function scope, which means that all the variables and functions declared inside a
                            function,
                            can be accessed from within the function and not outside of it.</p>
                        <pre><code class="language-javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">awesomeFunction</span>(<span class="hljs-params"></span>)</span>{
      <span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;
    
      <span class="hljs-keyword">var</span> multiplyBy2 = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-built_in">console</span>.log(a*<span class="hljs-number">2</span>); <span class="hljs-comment">// Can access variable "a" since a and multiplyBy2 both are written inside the same function</span>
      }
    }
    <span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">// Throws reference error since a is written in local scope and cannot be accessed outside</span>
    
    multiplyBy2(); <span class="hljs-comment">// Throws reference error since multiplyBy2 is written in local scope</span></code></pre>
                        <p><strong>Block Scope: </strong>Block scope is related to the variables declared using let and
                            const.
                            Variables declared with var do not have block scope. Block scope tells us that any variable
                            declared
                            inside a block { }, can be accessed only inside that block and cannot be accessed outside of
                            it.</p>
                        <pre><code class="language-javascript hljs">{
      <span class="hljs-keyword">let</span> x = <span class="hljs-number">45</span>;
    }
    
    <span class="hljs-built_in">console</span>.log(x); <span class="hljs-comment">// Gives reference error since x cannot be accessed outside of the block</span>
    
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">2</span>; i++){
      <span class="hljs-comment">// do something</span>
    }
    
    <span class="hljs-built_in">console</span>.log(i); <span class="hljs-comment">// Gives reference error since i cannot be accessed outside of the for loop block</span></code></pre>
                        <p><strong>Scope Chain: </strong>JavaScript engine also uses Scope to find variables. Let’s
                            understand
                            that using an example:</p>
                        <pre><code class="language-javascript hljs"><span class="hljs-keyword">var</span> y = <span class="hljs-number">24</span>;
    
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">favFunction</span>(<span class="hljs-params"></span>)</span>{
      <span class="hljs-keyword">var</span> x = <span class="hljs-number">667</span>;
      <span class="hljs-keyword">var</span> anotherFavFunction = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-built_in">console</span>.log(x); <span class="hljs-comment">// Does not find x inside anotherFavFunction, so looks for variable inside favFunction, outputs 667</span>
      }
    
      <span class="hljs-keyword">var</span> yetAnotherFavFunction = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-built_in">console</span>.log(y); <span class="hljs-comment">// Does not find y inside yetAnotherFavFunction, so looks for variable inside favFunction and does not find it, so looks for variable in global scope, finds it and outputs 24</span>
      }
    
      anotherFavFunction();
      yetAnotherFavFunction();
    }
    favFunction();</code></pre>
                        <p><strong>As you can see in the code above, if the javascript engine does not find the variable
                                in
                                local scope, it tries to check for the variable in the outer scope. If the variable does
                                not
                                exist in the outer scope, it tries to find the variable in the global scope.</strong>
                        </p>
                        <p>If the variable is not found in the global space as well, a reference error is thrown.</p>
                    </article>
                    <div class="ibpage-article-problems" id="19">


                    </div>
                </section>
                <section class="ibpage-article-header" id="explain-closures">
                    <h3>20. Explain Closures in JavaScript.</h3>
                    <article class="ibpage-article">
                        <p>Closures are an ability of a function to remember the variables and functions that are
                            declared in
                            its outer scope.</p>
                        <pre><code class="language-javascript hljs"><span class="hljs-keyword">var</span> Person = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">pName</span>)</span>{
      <span class="hljs-keyword">var</span> name = pName;
    
      <span class="hljs-built_in">this</span>.getName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-keyword">return</span> name;
      }
    }
    
    <span class="hljs-keyword">var</span> person = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">"Neelesh"</span>);
    <span class="hljs-built_in">console</span>.log(person.getName());</code></pre>
                        <p>Let’s understand closures by example:</p>
                        <pre><code class="language-javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">randomFunc</span>(<span class="hljs-params"></span>)</span>{
      <span class="hljs-keyword">var</span> obj1 = {<span class="hljs-attr">name</span>:<span class="hljs-string">"Vivian"</span>, <span class="hljs-attr">age</span>:<span class="hljs-number">45</span>};
    
      <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-built_in">console</span>.log(obj1.name + <span class="hljs-string">" is "</span>+ <span class="hljs-string">"awesome"</span>); <span class="hljs-comment">// Has access to obj1 even when the randomFunc function is executed</span>
    
      }
    }
    
    <span class="hljs-keyword">var</span> initialiseClosure = randomFunc(); <span class="hljs-comment">// Returns a function</span>
    
    initialiseClosure(); </code></pre>
                        <p>Let’s understand the code above,<br><br>The function randomFunc() gets executed and returns a
                            function when we assign it to a variable:</p>
                        <pre><code class="language-javascript hljs"><span class="hljs-keyword">var</span> initialiseClosure = randomFunc();</code></pre>
                        <p>The returned function is then executed when we invoke initialiseClosure:</p>
                        <pre><code class="language-javascript hljs">initialiseClosure(); </code></pre>
                        <p>The line of code above outputs “Vivian is awesome” and this is possible because of closure.
                        </p>
                        <pre><code class="language-javascript hljs"><span class="hljs-built_in">console</span>.log(obj1.name + <span class="hljs-string">" is "</span>+ <span class="hljs-string">"awesome"</span>);</code></pre>
                        <p>When the function randomFunc() runs, it seems that the returning function is using the
                            variable obj1
                            inside it:</p>
                        <p>Therefore randomFunc(), instead of destroying the value of obj1 after execution,
                            <strong>saves the
                                value in the memory for further reference.</strong> This is the reason why the returning
                            function is able to use the variable declared in the outer scope even after the function is
                            already
                            executed.<br><br><strong>This ability of a function to store a variable for further
                                reference even
                                after it is executed is called Closure.</strong></p>
                    </article>
                    <div class="ibpage-article-problems" id="20">


                    </div>
                </section>
                <section class="ibpage-article-header" id="advantages-of-javascript">
                    <h3>21. Mention some advantages of javascript.</h3>
                    <article class="ibpage-article">
                        <p>There are many advantages of javascript. Some of them are&nbsp;</p>
                        <ol>
                            <li>Javascript is executed on the client-side as well as server-side also. There are a
                                variety of
                                Frontend Frameworks that you may study and utilize. However, if you want to use
                                JavaScript on
                                the backend, you'll need to learn NodeJS. It is currently the only JavaScript framework
                                that may
                                be used on the backend.</li>
                            <li>Javascript is a simple language to learn.</li>
                            <li>Web pages now have more functionality because of Javascript.</li>
                            <li>To the end-user, Javascript is quite quick.</li>
                        </ol>
                    </article>
                    <div class="ibpage-article-problems" id="21">


                    </div>
                </section>
                <section class="ibpage-article-header" id="object-prototypes">
                    <h3>22. What are object prototypes?</h3>
                    <article class="ibpage-article">
                        <p>All javascript objects inherit properties from a prototype. For example,</p>
                        <ul>
                            <li>Date objects inherit properties from the Date prototype</li>
                            <li>Math objects inherit properties from the Math prototype</li>
                            <li>Array objects inherit properties from the Array prototype.</li>
                            <li>On top of the chain is <strong>Object.prototype. </strong>Every prototype inherits
                                properties
                                and methods from the Object.prototype.</li>
                            <li>
                                <strong>A prototype is a blueprint of an object. The prototype</strong> allows us to use
                                properties and methods on an object even if the properties and methods do not exist on
                                the
                                current object.
                            </li>
                        </ul>
                        <p>Let’s see prototypes help us use methods and properties:</p>
                        <figure class="image image_resized" style="width:75%;"><img
                                data-src="https://d3n0h9tb65y8q.cloudfront.net/public_assets/assets/000/003/411/original/object_prototypes.png?1654853384"
                                class="lazy-elem"></figure>
                        <pre><code class="language-javascript hljs"><span class="hljs-keyword">var</span> arr = [];
    arr.push(<span class="hljs-number">2</span>);
    
    <span class="hljs-built_in">console</span>.log(arr); <span class="hljs-comment">// Outputs [2]</span></code></pre>
                        <p>In the code above, as one can see, we have not defined any property or method called push on
                            the
                            array “arr” but the javascript engine does not throw an error.</p>
                        <p>The reason is the use of prototypes. As we discussed before, Array objects inherit properties
                            from
                            the Array prototype.</p>
                        <p>The javascript engine sees that the method push does not exist on the current array object
                            and
                            therefore, looks for the method push inside the Array prototype and it finds the method.</p>
                        <p>Whenever the property or method is not found on the current object, the javascript engine
                            will always
                            try to look in its prototype and if it still does not exist, it looks inside the prototype's
                            prototype and so on.</p>
                    </article>
                    <div class="ibpage-article-problems" id="22">


                    </div>
                </section>
                <section class="ibpage-article-header" id="callbacks">
                    <h3>23. What are callbacks?</h3>
                    <article class="ibpage-article">
                        <p>A callback is a function that will be executed after another function gets executed. In
                            javascript,
                            functions are treated as first-class citizens, they can be used as an argument of another
                            function,
                            can be returned by another function, and can be used as a property of an object.</p>
                        <p><strong>Functions that are used as an argument to another function are called callback
                                functions.
                            </strong>Example:</p>
                        <pre><code class="language-javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">divideByHalf</span>(<span class="hljs-params">sum</span>)</span>{
      <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Math</span>.floor(sum / <span class="hljs-number">2</span>));
    }
    
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">multiplyBy2</span>(<span class="hljs-params">sum</span>)</span>{
      <span class="hljs-built_in">console</span>.log(sum * <span class="hljs-number">2</span>);
    }
    
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">operationOnSum</span>(<span class="hljs-params">num1,num2,operation</span>)</span>{
      <span class="hljs-keyword">var</span> sum = num1 + num2;
      operation(sum);
    }
    
    operationOnSum(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>, divideByHalf); <span class="hljs-comment">// Outputs 3</span>
    
    operationOnSum(<span class="hljs-number">5</span>, <span class="hljs-number">5</span>, multiplyBy2); <span class="hljs-comment">// Outputs 20</span></code></pre>
                        <ul>
                            <li>In the code above, we are performing mathematical operations on the sum of two numbers.
                                The
                                operationOnSum function takes 3 arguments, the first number, the second number, and the
                                operation that is to be performed on their sum (callback).</li>
                            <li>Both divideByHalf and multiplyBy2 functions are used as callback functions in the code
                                above.
                            </li>
                            <li>These callback functions will be executed only after the function operationOnSum is
                                executed.
                            </li>
                            <li>Therefore, a callback is a function that will be executed after another function gets
                                executed.
                            </li>
                        </ul>
                    </article>
                    <div class="ibpage-article-problems" id="23">


                    </div>
                </section>
                <section class="ibpage-article-header" id="types-of-errors">
                    <h3>24. What are the types of errors in javascript?</h3>
                    <article class="ibpage-article">
                        <p>There are two types of errors in javascript.</p>
                        <ol>
                            <li>
                                <strong>Syntax error</strong>: Syntax errors are mistakes or spelling problems in the
                                code that
                                cause the program to not execute at all or to stop running halfway through. Error
                                messages are
                                usually supplied as well.
                            </li>
                            <li>
                                <strong>Logical error</strong>: Reasoning mistakes occur when the syntax is proper but
                                the logic
                                or program is incorrect. The application executes without problems in this case.
                                However, the
                                output findings are inaccurate. These are sometimes more difficult to correct than
                                syntax issues
                                since these applications do not display error signals for logic faults.
                            </li>
                        </ol>
                    </article>
                    <div class="ibpage-article-problems" id="24">


                    </div>
                </section>
                <section class="ibpage-article-header" id="memoization">
                    <h3>25. What is memoization?</h3>
                    <article class="ibpage-article">
                        <p>Memoization is a form of caching where the return value of a function is cached based on its
                            parameters. If the parameter of that function is not changed, the cached version of the
                            function is
                            returned.<br>Let’s understand memoization, by converting a simple function to a memoized
                            function:
                        </p>
                        <blockquote>
                            <p>Note- Memoization is used for expensive function calls but in the following example, we
                                are
                                considering a simple function for understanding the concept of memoization better.</p>
                        </blockquote>
                        <p>Consider the following function:</p>
                        <pre><code class="language-javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addTo256</span>(<span class="hljs-params">num</span>)</span>{
      <span class="hljs-keyword">return</span> num + <span class="hljs-number">256</span>;
    }
    addTo256(<span class="hljs-number">20</span>); <span class="hljs-comment">// Returns 276</span>
    addTo256(<span class="hljs-number">40</span>); <span class="hljs-comment">// Returns 296</span>
    addTo256(<span class="hljs-number">20</span>); <span class="hljs-comment">// Returns 276</span></code></pre>
                        <p>In the code above, we have written a function that adds the parameter to 256 and returns
                            it.<br><br>When we are calling the function addTo256 again with the same parameter (“20” in
                            the case
                            above), we are computing the result again for the same parameter.<br><br>Computing the
                            result with
                            the same parameter, again and again, is not a big deal in the above case, but imagine if the
                            function does some heavy-duty work, then, computing the result again and again with the same
                            parameter will lead to wastage of time.</p>
                        <p>This is where memoization comes in, by using memoization we can store(cache) the computed
                            results
                            based on the parameters. If the same parameter is used again while invoking the function,
                            instead of
                            computing the result, we directly return the stored (cached) value.</p>
                        <p>Let’s convert the above function addTo256, to a memoized function:</p>
                        <pre><code class="language-javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">memoizedAddTo256</span>(<span class="hljs-params"></span>)</span>{
      <span class="hljs-keyword">var</span> cache = {};
    
      <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">num</span>)</span>{
        <span class="hljs-keyword">if</span>(num <span class="hljs-keyword">in</span> cache){
          <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"cached value"</span>);
          <span class="hljs-keyword">return</span> cache[num]
        }
        <span class="hljs-keyword">else</span>{
          cache[num] = num + <span class="hljs-number">256</span>;
          <span class="hljs-keyword">return</span> cache[num];
        }
      }
    }
    <span class="hljs-keyword">var</span> memoizedFunc = memoizedAddTo256();
    
    memoizedFunc(<span class="hljs-number">20</span>); <span class="hljs-comment">// Normal return</span>
    memoizedFunc(<span class="hljs-number">20</span>); <span class="hljs-comment">// Cached return</span></code></pre>
                        <p>In the code above, if we run the memoizedFunc function with the same parameter, instead of
                            computing
                            the result again, it returns the cached result.</p>
                        <blockquote>
                            <p>Note- Although using memoization saves time, it results in larger consumption of memory
                                since we
                                are storing all the computed results.</p>
                        </blockquote>
                    </article>
                    <div class="ibpage-article-problems" id="25">


                    </div>
                </section>
                <section class="ibpage-article-header" id="recursion-in-a-programming-language">
                    <h3>26. What is recursion in a programming language?</h3>
                    <article class="ibpage-article">
                        <p>Recursion is a technique to iterate over an operation by having a function call itself
                            repeatedly
                            until it arrives at a result.</p>
                        <pre><code class="language-plaintext hljs">function add(number) {
      if (number &lt;= 0) {
        return 0;
      } else {
        return number + add(number - 1);
      }
    }
    add(3) =&gt; 3 + add(2)
              3 + 2 + add(1)
              3 + 2 + 1 + add(0)
              3 + 2 + 1 + 0 = 6  </code></pre>
                        <p>Example of a recursive function:<br><br>The following function calculates the sum of all the
                            elements
                            in an array by using recursion:</p>
                        <pre><code class="language-plaintext hljs">function computeSum(arr){
      if(arr.length === 1){
        return arr[0];
      }
      else{
        return arr.pop() + computeSum(arr);
      }
    }
    computeSum([7, 8, 9, 99]); // Returns 123</code></pre>
                    </article>
                    <div class="ibpage-article-problems" id="26">



                    </div>
                </section>
                <section class="ibpage-article-header" id="use-of-a-constructor-function">
                    <h3>27. What is the use of a constructor function in javascript?</h3>
                    <article class="ibpage-article">
                        <p>Constructor functions are used to create objects in javascript.</p>
                        <p>When do we use constructor functions?</p>
                        <p>If we want to create multiple objects having similar properties and methods, constructor
                            functions
                            are used.</p>
                        <blockquote>
                            <h4><strong>Note- The name of a constructor function should always be written in Pascal
                                    Notation:
                                    every word should start with a capital letter.</strong></h4>
                        </blockquote>
                        <p>Example:</p>
                        <pre><code class="language-javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name,age,gender</span>)</span>{
      <span class="hljs-built_in">this</span>.name = name;
      <span class="hljs-built_in">this</span>.age = age;
      <span class="hljs-built_in">this</span>.gender = gender;
    }
    
    
    <span class="hljs-keyword">var</span> person1 = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">"Vivek"</span>, <span class="hljs-number">76</span>, <span class="hljs-string">"male"</span>);
    <span class="hljs-built_in">console</span>.log(person1);
    
    <span class="hljs-keyword">var</span> person2 = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">"Courtney"</span>, <span class="hljs-number">34</span>, <span class="hljs-string">"female"</span>);
    <span class="hljs-built_in">console</span>.log(person2);</code></pre>
                        <p>In the code above, we have created a constructor function named Person. Whenever we want to
                            create a
                            new object of the type Person, We need to create it using the new keyword:</p>
                        <pre><code class="language-javascript hljs"><span class="hljs-keyword">var</span> person3 = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">"Lilly"</span>, <span class="hljs-number">17</span>, <span class="hljs-string">"female"</span>);</code></pre>
                        <p>The above line of code will create a new object of the type Person. Constructor functions
                            allow us to
                            group similar objects.</p>
                    </article>
                    <div class="ibpage-article-problems" id="27">


                    </div>
                </section>
                <section class="ibpage-article-header" id="dom">
                    <h3>28. What is DOM?</h3>
                    <article class="ibpage-article">
                        <ul>
                            <li>DOM stands for Document Object Model. &nbsp;DOM is a programming interface for HTML and
                                XML
                                documents.</li>
                            <li>When the browser tries to render an HTML document, it creates an object based on the
                                HTML
                                document called DOM. Using this DOM, we can manipulate or change various elements inside
                                the
                                HTML document.</li>
                            <li>Example of how HTML code gets converted to DOM:</li>
                        </ul>
                        <figure class="image image_resized" style="width:75%;"><img
                                data-src="https://d3n0h9tb65y8q.cloudfront.net/public_assets/assets/000/003/412/original/DOM.png?1654853759"
                                class="lazy-elem"></figure>
                    </article>
                    <div class="ibpage-article-problems" id="28">


                    </div>
                </section>
                <section class="ibpage-article-header"
                    id="which-method-is-used-to-retrieve-a-character-from-a-certain-index">
                    <h3>29. Which method is used to retrieve a character from a certain index?</h3>
                    <article class="ibpage-article">
                        <p>The charAt() function of the JavaScript string finds a char element at the supplied index.
                            The index
                            number begins at 0 and continues up to n-1, Here n is the string length. The index value
                            must be
                            positive, higher than, or the same as the string length.</p>
                    </article>
                    <div class="ibpage-article-problems" id="29">


                    </div>
                </section>
                <section class="ibpage-article-header" id="bom">
                    <h3>30. What do you mean by BOM?</h3>
                    <article class="ibpage-article">
                        <p>Browser Object Model is known as BOM. It allows users to interact with the browser. A
                            browser's
                            initial object is a window. As a result, you may call all of the window's functions directly
                            or by
                            referencing the window. The document, history, screen, navigator, location, and other
                            attributes are
                            available in the window object.</p>
                    </article>
                    <div class="ibpage-article-problems" id="30">


                    </div>
                </section>
                <section class="ibpage-article-header" id="distinction-between-client-side-and-server-side-javascript">
                    <h3>31. What is the distinction between client-side and server-side JavaScript?</h3>
                    <article class="ibpage-article">
                        <p>Client-side JavaScript is made up of two parts, a fundamental language and predefined objects
                            for
                            performing JavaScript in a browser. JavaScript for the client is automatically included in
                            the HTML
                            pages. At runtime, the browser understands this script.</p>
                        <figure class="image image_resized" style="width:75%;"><img
                                data-src="https://d3n0h9tb65y8q.cloudfront.net/public_assets/assets/000/003/413/original/client-side_and_server-side.png?1654854025"
                                class="lazy-elem"></figure>
                        <p>Client-side JavaScript is similar to server-side JavaScript. It includes JavaScript that will
                            execute
                            on a server. Only after processing is the server-side JavaScript deployed.</p>
                    </article>
                    <div class="ibpage-article-problems" id="31">


                    </div>
                </section>

            </div>
            <div data-scroll-id="1" data-scroll-identifier="each-article-section" id="experienced">
                <h2>JavaScript Interview Questions for Experienced</h2>

                <section class="ibpage-article-header" id="arrow-functions">
                    <h3>32. What are arrow functions?</h3>
                    <article class="ibpage-article">
                        <p>Arrow functions were introduced in the ES6 version of javascript. They provide us with a new
                            and
                            shorter syntax for declaring functions. Arrow functions can only be used as a function
                            expression.<br><br>Let’s compare the normal function declaration and the arrow function
                            declaration
                            in detail:</p>
                        <pre><code class="language-javascript hljs"><span class="hljs-comment">// Traditional Function Expression</span>
    <span class="hljs-keyword">var</span> add = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a,b</span>)</span>{
      <span class="hljs-keyword">return</span> a + b;
    }
    
    <span class="hljs-comment">// Arrow Function Expression</span>
    <span class="hljs-keyword">var</span> arrowAdd = <span class="hljs-function">(<span class="hljs-params">a,b</span>) =&gt;</span> a + b;</code></pre>
                        <p>Arrow functions are declared without the function keyword. If there is only one returning
                            expression
                            then we don’t need to use the return keyword as well in an arrow function as shown in the
                            example
                            above. Also, for functions having just one line of code, curly braces { } can be omitted.
                        </p>
                        <pre><code class="language-javascript hljs"><span class="hljs-comment">// Traditional function expression</span>
    <span class="hljs-keyword">var</span> multiplyBy2 = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">num</span>)</span>{
      <span class="hljs-keyword">return</span> num * <span class="hljs-number">2</span>;
    }
    <span class="hljs-comment">// Arrow function expression</span>
    <span class="hljs-keyword">var</span> arrowMultiplyBy2 = <span class="hljs-function"><span class="hljs-params">num</span> =&gt;</span> num * <span class="hljs-number">2</span>;</code></pre>
                        <p>If the function takes in only one argument, then the parenthesis () around the parameter can
                            be
                            omitted as shown in the code above.&nbsp;</p>
                        <pre><code class="language-javascript hljs"><span class="hljs-keyword">var</span> obj1 = {
      <span class="hljs-attr">valueOfThis</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;
      }
    }
    <span class="hljs-keyword">var</span> obj2 = {
      <span class="hljs-attr">valueOfThis</span>: <span class="hljs-function">()=&gt;</span>{
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;
      }
    }
    
    obj1.valueOfThis(); <span class="hljs-comment">// Will return the object obj1</span>
    obj2.valueOfThis(); <span class="hljs-comment">// Will return window/global object</span></code></pre>
                        <p>The biggest difference between the traditional function expression and the arrow function is
                            the
                            handling of <strong>this </strong>keyword. By general definition, <strong>this
                            </strong>keyword
                            always refers to the object that is calling the function. As you can see in the code above,
                            <strong>obj1.valueOfThis() </strong>returns obj1 since <strong>this </strong>keyword refers
                            to the
                            object calling the function.
                        </p>
                        <p>In the arrow functions, there is no binding of <strong>this </strong>keyword. This<strong>
                            </strong>keyword inside an arrow function does not refer to the object calling it. It rather
                            inherits its value from the parent scope which is the window object in this case. Therefore,
                            in the
                            code above, <strong>obj2.valueOfThis() </strong>returns the window object.</p>
                    </article>
                    <div class="ibpage-article-problems" id="32">



                    </div>
                </section>
                <section class="ibpage-article-header" id="prototype-design-pattern">
                    <h3>33. What do mean by prototype design pattern?</h3>
                    <article class="ibpage-article">
                        <p>The Prototype Pattern produces different objects, but instead of returning uninitialized
                            objects, it
                            produces objects that have values replicated from a template – or sample – object. Also
                            known as the
                            Properties pattern, the Prototype pattern is used to create prototypes.</p>
                        <p>The introduction of business objects with parameters that match the database's default
                            settings is a
                            good example of where the Prototype pattern comes in handy. The default settings for a newly
                            generated business object are stored in the prototype object.</p>
                        <p>The Prototype pattern is hardly used in traditional languages, however, it is used in the
                            development
                            of new objects and templates in JavaScript, which is a prototypal language.</p>
                    </article>
                    <div class="ibpage-article-problems" id="33">


                    </div>
                </section>
                <section class="ibpage-article-header"
                    id="differences-between-declaring-variables-using-var-let-and-const">
                    <h3>34. Differences between declaring variables using var, let and const.</h3>
                    <article class="ibpage-article">
                        <p>Before the ES6 version of javascript, only the keyword var was used to declare variables.
                            With the
                            ES6 Version, keywords let and const were introduced to declare variables.</p>
                        <figure class="table">
                            <table>
                                <tbody>
                                    <tr>
                                        <td>keyword</td>
                                        <td>const</td>
                                        <td>let</td>
                                        <td>var</td>
                                    </tr>
                                    <tr>
                                        <td>global scope</td>
                                        <td>no</td>
                                        <td>no</td>
                                        <td>yes</td>
                                    </tr>
                                    <tr>
                                        <td>function scope</td>
                                        <td>yes</td>
                                        <td>yes</td>
                                        <td>yes</td>
                                    </tr>
                                    <tr>
                                        <td>block scope</td>
                                        <td>yes</td>
                                        <td>yes</td>
                                        <td>no</td>
                                    </tr>
                                    <tr>
                                        <td>can be reassigned</td>
                                        <td>no</td>
                                        <td>yes</td>
                                        <td>yes</td>
                                    </tr>
                                </tbody>
                            </table>
                        </figure>
                        <p><strong>Let’s understand the differences with examples:</strong></p>
                        <pre><code class="language-javascript hljs"><span class="hljs-keyword">var</span> variable1 = <span class="hljs-number">23</span>;
    
    <span class="hljs-keyword">let</span> variable2 = <span class="hljs-number">89</span>;
    
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">catchValues</span>(<span class="hljs-params"></span>)</span>{
      <span class="hljs-built_in">console</span>.log(variable1);
      <span class="hljs-built_in">console</span>.log(variable2);
    
    <span class="hljs-comment">// Both the variables can be accessed anywhere since they are declared in the global scope</span>
    }
    
    <span class="hljs-built_in">window</span>.variable1; <span class="hljs-comment">// Returns the value 23</span>
    
    <span class="hljs-built_in">window</span>.variable2; <span class="hljs-comment">// Returns undefined</span></code></pre>
                        <ul>
                            <li>The variables declared with the let keyword in the global scope behave just like the
                                variable
                                declared with the var keyword in the global scope.</li>
                            <li>Variables declared in the global scope with var and let keywords can be accessed from
                                anywhere
                                in the code.</li>
                            <li>But, there is one difference! Variables that are declared with the var keyword in the
                                global
                                scope are added to the window/global object. Therefore, they can be accessed using
                                window.variableName.<br>Whereas, the variables declared with the let keyword are not
                                added to
                                the global object, therefore, trying to access such variables using window.variableName
                                results
                                in an error.</li>
                        </ul>
                        <p><strong>var vs let in functional scope</strong></p>
                        <pre><code class="language-javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">varVsLetFunction</span>(<span class="hljs-params"></span>)</span>{
      <span class="hljs-keyword">let</span> awesomeCar1 = <span class="hljs-string">"Audi"</span>;
      <span class="hljs-keyword">var</span> awesomeCar2 = <span class="hljs-string">"Mercedes"</span>;
    }
    
    <span class="hljs-built_in">console</span>.log(awesomeCar1); <span class="hljs-comment">// Throws an error</span>
    <span class="hljs-built_in">console</span>.log(awesomeCar2); <span class="hljs-comment">// Throws an error</span></code></pre>
                        <p>Variables are declared in a functional/local scope using <strong>var </strong>and <strong>let
                            </strong>keywords behave exactly the same, meaning, they cannot be accessed from outside of
                            the
                            scope.&nbsp;</p>
                        <pre><code class="language-javascript hljs">{
      <span class="hljs-keyword">var</span> variable3 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];
    }
    
    <span class="hljs-built_in">console</span>.log(variable3); <span class="hljs-comment">// Outputs [1,2,3,4]</span>
    
    {
      <span class="hljs-keyword">let</span> variable4 = [<span class="hljs-number">6</span>, <span class="hljs-number">55</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">2</span>];
    }
    
    <span class="hljs-built_in">console</span>.log(variable4); <span class="hljs-comment">// Throws error</span>
    
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++){
      <span class="hljs-comment">//Do something</span>
    }
    
    <span class="hljs-built_in">console</span>.log(i); <span class="hljs-comment">// Throws error</span>
    
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">2</span>; i++){
      <span class="hljs-comment">// Do something</span>
    }
    
    <span class="hljs-built_in">console</span>.log(j) <span class="hljs-comment">// Outputs 2 </span></code></pre>
                        <ul>
                            <li>In javascript, a block means the code written inside the curly braces
                                <strong>{}</strong>.</li>
                            <li>Variables declared with <strong>var </strong>keyword do not have block scope. It means a
                                variable declared in block scope <strong>{} </strong>with the <strong>var
                                </strong>keyword is
                                the same as declaring the variable in the global scope.</li>
                            <li>Variables declared with <strong>let </strong>keyword inside the block scope cannot be
                                accessed
                                from outside of the block.</li>
                        </ul>
                        <p><strong>Const keyword</strong></p>
                        <ul>
                            <li>Variables with the <strong>const </strong>keyword behave exactly like a variable
                                declared with
                                the let keyword with only one difference, <strong>any variable declared with the const
                                    keyword
                                    cannot be reassigned.</strong>
                            </li>
                            <li>Example:</li>
                        </ul>
                        <pre><code class="language-javascript hljs"><span class="hljs-keyword">const</span> x = {<span class="hljs-attr">name</span>:<span class="hljs-string">"Vivek"</span>};
    
    x = {<span class="hljs-attr">address</span>: <span class="hljs-string">"India"</span>}; <span class="hljs-comment">// Throws an error</span>
    
    x.name = <span class="hljs-string">"Nikhil"</span>; <span class="hljs-comment">// No error is thrown</span>
    
    <span class="hljs-keyword">const</span> y = <span class="hljs-number">23</span>;
    
    y = <span class="hljs-number">44</span>; <span class="hljs-comment">// Throws an error</span></code></pre>
                        <p>In the code above, although we can change the value of a property inside the variable
                            declared with
                            <strong>const </strong>keyword, we cannot completely reassign the variable itself.
                        </p>
                    </article>
                    <div class="ibpage-article-problems" id="34">


                    </div>
                </section>
                <section class="ibpage-article-header" id="rest-parameter-and-spread-operator">
                    <h3>35. What is the rest parameter and spread operator?</h3>
                    <article class="ibpage-article">
                        <p>Both rest parameter and spread operator were introduced in the ES6 version of
                            javascript.<br><br><strong>Rest parameter ( … ):</strong></p>
                        <ul>
                            <li>It provides an improved way of handling the parameters of a function.</li>
                            <li>Using the rest parameter syntax, we can create functions that can take a variable number
                                of
                                arguments.</li>
                            <li>Any number of arguments will be converted into an array using the rest parameter.</li>
                            <li>It also helps in extracting all or some parts of the arguments.</li>
                            <li>Rest parameters can be used by applying three dots (...) before the parameters.</li>
                        </ul>
                        <pre><code class="language-javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">extractingArgs</span>(<span class="hljs-params">...args</span>)</span>{
      <span class="hljs-keyword">return</span> args[<span class="hljs-number">1</span>];
    }
    
    <span class="hljs-comment">// extractingArgs(8,9,1); // Returns 9</span>
    
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addAllArgs</span>(<span class="hljs-params">...args</span>)</span>{
      <span class="hljs-keyword">let</span> sumOfArgs = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">while</span>(i &lt; args.length){
        sumOfArgs += args[i];
        i++;
      }
      <span class="hljs-keyword">return</span> sumOfArgs;
    }
    
    addAllArgs(<span class="hljs-number">6</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">99</span>); <span class="hljs-comment">// Returns 117</span>
    addAllArgs(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>); <span class="hljs-comment">// Returns 8</span></code></pre>
                        <p><strong>**Note- Rest parameter should always be used at the last parameter of a
                                function:</strong>
                        </p>
                        <pre><code class="language-javascript hljs"><span class="hljs-comment">// Incorrect way to use rest parameter</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">randomFunc</span>(<span class="hljs-params">a,...args,c</span>)</span>{
    <span class="hljs-comment">//Do something</span>
    }
    
    <span class="hljs-comment">// Correct way to use rest parameter</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">randomFunc2</span>(<span class="hljs-params">a,b,...args</span>)</span>{
    <span class="hljs-comment">//Do something</span>
    }</code></pre>
                        <ul>
                            <li>
                                <strong>Spread operator (…): </strong>Although the syntax of the spread operator is
                                exactly the
                                same as the rest parameter, the spread operator is used to spreading an array, and
                                object
                                literals. We also use spread operators where one or more arguments are expected in a
                                function
                                call.
                            </li>
                        </ul>
                        <pre><code class="language-javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addFourNumbers</span>(<span class="hljs-params">num1,num2,num3,num4</span>)</span>{
      <span class="hljs-keyword">return</span> num1 + num2 + num3 + num4;
    }
    
    <span class="hljs-keyword">let</span> fourNumbers = [<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>];
    
    
    addFourNumbers(...fourNumbers);
    <span class="hljs-comment">// Spreads [5,6,7,8] as 5,6,7,8</span>
    
    <span class="hljs-keyword">let</span> array1 = [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>];
    <span class="hljs-keyword">let</span> clonedArray1 = [...array1];
    <span class="hljs-comment">// Spreads the array into 3,4,5,6</span>
    <span class="hljs-built_in">console</span>.log(clonedArray1); <span class="hljs-comment">// Outputs [3,4,5,6]</span>
    
    
    <span class="hljs-keyword">let</span> obj1 = {<span class="hljs-attr">x</span>:<span class="hljs-string">'Hello'</span>, <span class="hljs-attr">y</span>:<span class="hljs-string">'Bye'</span>};
    <span class="hljs-keyword">let</span> clonedObj1 = {...obj1}; <span class="hljs-comment">// Spreads and clones obj1</span>
    <span class="hljs-built_in">console</span>.log(obj1);
    
    <span class="hljs-keyword">let</span> obj2 = {<span class="hljs-attr">z</span>:<span class="hljs-string">'Yes'</span>, <span class="hljs-attr">a</span>:<span class="hljs-string">'No'</span>};
    <span class="hljs-keyword">let</span> mergedObj = {...obj1, ...obj2}; <span class="hljs-comment">// Spreads both the objects and merges it</span>
    <span class="hljs-built_in">console</span>.log(mergedObj);
    <span class="hljs-comment">// Outputs {x:'Hello', y:'Bye',z:'Yes',a:'No'};</span></code></pre>
                        <blockquote>
                            <p>***Note- Key differences between rest parameter and spread operator:</p>
                            <ul>
                                <li>Rest parameter is used to take a variable number of arguments and turns them into an
                                    array
                                    while the spread operator takes an array or an object and spreads it</li>
                                <li>Rest parameter is used in function declaration whereas the spread operator is used
                                    in
                                    function calls.</li>
                            </ul>
                        </blockquote>
                    </article>
                    <div class="ibpage-article-problems" id="35">


                    </div>
                </section>
                <section class="ibpage-article-header" id="different-methods-can-you-make-an-object">
                    <h3>36. In JavaScript, how many different methods can you make an object?</h3>
                    <article class="ibpage-article">
                        <p>In JavaScript, there are several ways to declare or construct an object.</p>
                        <ol>
                            <li>Object.</li>
                            <li>using Class.</li>
                            <li>create Method.</li>
                            <li>Object Literals.</li>
                            <li>using Function.</li>
                            <li>Object Constructor.</li>
                        </ol>
                    </article>
                    <div class="ibpage-article-problems" id="36">


                    </div>
                </section>
                <section class="ibpage-article-header" id="use-of-promises">
                    <h3>37. What is the use of promises in javascript?</h3>
                    <article class="ibpage-article">
                        <p><strong>Promises are used to handle asynchronous operations in
                                javascript.</strong><br><br>Before
                            promises, callbacks were used to handle asynchronous operations. But due to the limited
                            functionality of callbacks, using multiple callbacks to handle asynchronous code can lead to
                            unmanageable code.<br><br>Promise object has four states -</p>
                        <ul>
                            <li>Pending - Initial state of promise. This state represents that the promise has neither
                                been
                                fulfilled nor been rejected, it is in the pending state.</li>
                            <li>Fulfilled - This state represents that the promise has been fulfilled, meaning the async
                                operation is completed.</li>
                            <li>Rejected - This state represents that the promise has been rejected for some reason,
                                meaning the
                                async operation has failed.</li>
                            <li>Settled - This state represents that the promise has been either rejected or fulfilled.
                            </li>
                        </ul>
                        <p>A promise is created using the <strong>Promise </strong>constructor which takes in a callback
                            function with two parameters, <strong>resolve </strong>and <strong>reject
                            </strong>respectively.</p>
                        <figure class="image image_resized" style="width:50%;"><img
                                data-src="https://d3n0h9tb65y8q.cloudfront.net/public_assets/assets/000/003/414/original/promise.png?1654854623"
                                class="lazy-elem"></figure>
                        <p><strong>resolve </strong>is a function that will be called when the async operation has been
                            successfully completed.<br><br><strong>reject </strong>is a function that will be called,
                            when the
                            async operation fails or if some error occurs.<br><br>Example of a
                            promise:<br><br><strong>Promises
                                are used to handle asynchronous operations like server requests, for ease of
                                understanding, we
                                are using an operation to calculate the sum of three elements.</strong><br><br>In the
                            function
                            below, we are returning a promise inside a function:</p>
                        <pre><code class="language-javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sumOfThreeElements</span>(<span class="hljs-params">...elements</span>)</span>{
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>{
        <span class="hljs-keyword">if</span>(elements.length &gt; <span class="hljs-number">3</span> ){
          reject(<span class="hljs-string">"Only three elements or less are allowed"</span>);
        }
        <span class="hljs-keyword">else</span>{
          <span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>;
          <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;
          <span class="hljs-keyword">while</span>(i &lt; elements.length){
            sum += elements[i];
            i++;
          }
          resolve(<span class="hljs-string">"Sum has been calculated: "</span>+sum);
        }
      })
    }</code></pre>
                        <p>In the code above, we are calculating the sum of three elements, if the length of the
                            elements array
                            is more than 3, a promise is rejected, or else the promise is resolved and the sum is
                            returned.</p>
                        <p>We can consume any promise by attaching then() and catch() methods to the consumer.</p>
                        <figure class="image image_resized" style="width:75%;"><img
                                data-src="https://d3n0h9tb65y8q.cloudfront.net/public_assets/assets/000/003/416/original/Image-08.png?1654857201"
                                class="lazy-elem"></figure>
                        <p><strong>then() </strong>method is used to access the result when the promise is fulfilled.
                        </p>
                        <p><strong>catch() </strong>method is used to access the result/error when the promise is
                            rejected. In
                            the code below, we are consuming the promise:</p>
                        <pre><code class="language-javascript hljs">sumOfThreeElements(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>)
    .then(<span class="hljs-function"><span class="hljs-params">result</span>=&gt;</span> <span class="hljs-built_in">console</span>.log(result))
    .catch(<span class="hljs-function"><span class="hljs-params">error</span>=&gt;</span> <span class="hljs-built_in">console</span>.log(error));
    <span class="hljs-comment">// In the code above, the promise is fulfilled so the then() method gets executed</span>
    
    sumOfThreeElements(<span class="hljs-number">7</span>, <span class="hljs-number">0</span>, <span class="hljs-number">33</span>, <span class="hljs-number">41</span>)
    .then(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(result))
    .catch(<span class="hljs-function"><span class="hljs-params">error</span>=&gt;</span> <span class="hljs-built_in">console</span>.log(error));
    <span class="hljs-comment">// In the code above, the promise is rejected hence the catch() method gets executed</span></code></pre>
                    </article>
                    <div class="ibpage-article-problems" id="37">


                    </div>
                </section>
                <section class="ibpage-article-header" id="classes">
                    <h3>38. What are classes in javascript?</h3>
                    <article class="ibpage-article">
                        <p>Introduced in the ES6 version, classes are nothing but syntactic sugars for constructor
                            functions.
                            They provide a new way of declaring constructor functions in javascript. &nbsp;Below are the
                            examples of how classes are declared and used:</p>
                        <pre><code class="language-javascript hljs"><span class="hljs-comment">// Before ES6 version, using constructor functions</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Student</span>(<span class="hljs-params">name,rollNumber,grade,section</span>)</span>{
      <span class="hljs-built_in">this</span>.name = name;
      <span class="hljs-built_in">this</span>.rollNumber = rollNumber;
      <span class="hljs-built_in">this</span>.grade = grade;
      <span class="hljs-built_in">this</span>.section = section;
    }
    
    <span class="hljs-comment">// Way to add methods to a constructor function</span>
    Student.prototype.getDetails = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
      <span class="hljs-keyword">return</span> <span class="hljs-string">'Name: ${this.name}, Roll no: ${this.rollNumber}, Grade: ${this.grade}, Section:${this.section}'</span>;
    }
    
    
    <span class="hljs-keyword">let</span> student1 = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">"Vivek"</span>, <span class="hljs-number">354</span>, <span class="hljs-string">"6th"</span>, <span class="hljs-string">"A"</span>);
    student1.getDetails();
    <span class="hljs-comment">// Returns Name: Vivek, Roll no:354, Grade: 6th, Section:A</span>
    
    <span class="hljs-comment">// ES6 version classes</span>
    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span></span>{
      <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name,rollNumber,grade,section</span>)</span>{
        <span class="hljs-built_in">this</span>.name = name;
        <span class="hljs-built_in">this</span>.rollNumber = rollNumber;
        <span class="hljs-built_in">this</span>.grade = grade;
        <span class="hljs-built_in">this</span>.section = section;
      }
    
      <span class="hljs-comment">// Methods can be directly added inside the class</span>
      <span class="hljs-function"><span class="hljs-title">getDetails</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-keyword">return</span> <span class="hljs-string">'Name: ${this.name}, Roll no: ${this.rollNumber}, Grade:${this.grade}, Section:${this.section}'</span>;
      }
    }
    
    <span class="hljs-keyword">let</span> student2 = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">"Garry"</span>, <span class="hljs-number">673</span>, <span class="hljs-string">"7th"</span>, <span class="hljs-string">"C"</span>);
    student2.getDetails();
    <span class="hljs-comment">// Returns Name: Garry, Roll no:673, Grade: 7th, Section:C</span></code></pre>
                        <p>Key points to remember about classes:</p>
                        <ul>
                            <li>Unlike functions, classes are not hoisted. A class cannot be used before it is declared.
                            </li>
                            <li>A class can inherit properties and methods from other classes by using the extend
                                keyword.</li>
                            <li>All the syntaxes inside the class must follow the strict mode(‘use strict’) of
                                javascript. An
                                error will be thrown if the strict mode rules are not followed.</li>
                        </ul>
                    </article>
                    <div class="ibpage-article-problems" id="38">



                    </div>
                </section>
                <section class="ibpage-article-header" id="generator-functions">
                    <h3>39. What are generator functions?</h3>
                    <article class="ibpage-article">
                        <p>Introduced in the ES6 version, generator functions are a special class of
                            functions.<br><br><strong>They can be stopped midway and then continue from where they had
                                stopped.</strong><br><br>Generator functions are declared with the <strong>function*
                            </strong>keyword instead of the normal <strong>function </strong>keyword:</p>
                        <pre><code class="language-javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">genFunc</span>(<span class="hljs-params"></span>)</span>{
      <span class="hljs-comment">// Perform operation</span>
    }</code></pre>
                        <p>In normal functions, we use the <strong>return </strong>keyword to return a value and as soon
                            as the
                            return statement gets executed, the function execution stops:</p>
                        <pre><code class="language-javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">normalFunc</span>(<span class="hljs-params"></span>)</span>{
      <span class="hljs-keyword">return</span> <span class="hljs-number">22</span>;
      <span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>); <span class="hljs-comment">// This line of code does not get executed</span>
    }</code></pre>
                        <p>In the case of generator functions, when called, they do not execute the code, instead, they
                            return a
                            <strong>generator object</strong>. This generator object handles the execution.
                        </p>
                        <pre><code class="language-javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">genFunc</span>(<span class="hljs-params"></span>)</span>{
      <span class="hljs-keyword">yield</span> <span class="hljs-number">3</span>;
      <span class="hljs-keyword">yield</span> <span class="hljs-number">4</span>;
    }
    genFunc(); <span class="hljs-comment">// Returns Object [Generator] {}</span></code></pre>
                        <p>The generator object consists of a method called <strong>next()</strong>, this method when
                            called,
                            executes the code until the nearest <strong>yield </strong>statement, and returns the yield
                            value.<br><br>For example, if we run the next() method on the above code:</p>
                        <pre><code class="language-javascript hljs">genFunc().next(); <span class="hljs-comment">// Returns {value: 3, done:false}</span>
    </code></pre>
                        <p>As one can see the next method returns an object consisting of a <strong>value </strong>and
                            <strong>done </strong>properties. &nbsp;Value property represents the yielded value. Done
                            property
                            tells us whether the function code is finished or not. (Returns true if finished).
                        </p>
                        <p>Generator functions are used to return iterators. Let’s see an example where an iterator is
                            returned:
                        </p>
                        <pre><code class="language-javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">iteratorFunc</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++) {
          count++;
          <span class="hljs-keyword">yield</span> i;
      }
      <span class="hljs-keyword">return</span> count;
    }
    
    <span class="hljs-keyword">let</span> iterator = iteratorFunc();
    <span class="hljs-built_in">console</span>.log(iterator.next()); <span class="hljs-comment">// {value:0,done:false}</span>
    <span class="hljs-built_in">console</span>.log(iterator.next()); <span class="hljs-comment">// {value:1,done:false}</span>
    <span class="hljs-built_in">console</span>.log(iterator.next()); <span class="hljs-comment">// {value:2,done:true}</span></code></pre>
                        <p>As you can see in the code above, the last line returns <strong>done:true</strong>, since the
                            code
                            reaches the return statement.</p>
                    </article>
                    <div class="ibpage-article-problems" id="39">


                    </div>
                </section>
                <section class="ibpage-article-header" id="explain-weakset">
                    <h3>40. Explain WeakSet in javascript.</h3>
                    <article class="ibpage-article">
                        <p>In javascript, a Set is a collection of unique and ordered elements. Just like Set, WeakSet
                            is also a
                            collection of unique and ordered elements with some key differences:</p>
                        <ul>
                            <li>Weakset contains only objects and no other type.</li>
                            <li>An object inside the weakset is referenced weakly. This means, that if the object inside
                                the
                                weakset does not have a reference, it will be garbage collected.</li>
                            <li>Unlike Set, WeakSet only has three methods, <strong>add() </strong>, <strong>delete()
                                </strong>and <strong>has() </strong>.</li>
                        </ul>
                        <pre><code class="language-javascript hljs"><span class="hljs-keyword">const</span> newSet = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>]);
    <span class="hljs-built_in">console</span>.log(newSet);<span class="hljs-comment">// Outputs Set {4,5,6,7}</span>
    
    <span class="hljs-keyword">const</span> newSet2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakSet</span>([<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]); <span class="hljs-comment">//Throws an error</span>
    
    
    <span class="hljs-keyword">let</span> obj1 = {<span class="hljs-attr">message</span>:<span class="hljs-string">"Hello world"</span>};
    <span class="hljs-keyword">const</span> newSet3 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakSet</span>([obj1]);
    <span class="hljs-built_in">console</span>.log(newSet3.has(obj1)); <span class="hljs-comment">// true</span></code></pre>
                    </article>
                    <div class="ibpage-article-problems" id="40">


                    </div>
                </section>
                <section class="ibpage-article-header" id="why-do-we-use-callbacks">
                    <h3>41. Why do we use callbacks?</h3>
                    <article class="ibpage-article">
                        <p>A callback function is a method that is sent as an input to another function (now let us name
                            this
                            other function "thisFunction"), and it is performed inside the thisFunction after the
                            function has
                            completed execution.</p>
                        <p>JavaScript is a scripting language that is based on events. Instead of waiting for a reply
                            before
                            continuing, JavaScript will continue to run while monitoring for additional events.
                            Callbacks are a
                            technique of ensuring that a particular code does not run until another code has completed
                            its
                            execution.</p>
                    </article>
                    <div class="ibpage-article-problems" id="41">


                    </div>
                </section>
                <section class="ibpage-article-header" id="explain-weakmap">
                    <h3>42. Explain WeakMap in javascript.</h3>
                    <article class="ibpage-article">
                        <p>In javascript, Map is used to store key-value pairs. The key-value pairs can be of both
                            primitive and
                            non-primitive types. WeakMap is similar to Map with key differences:</p>
                        <ul>
                            <li>The keys and values in weakmap should always be an object.</li>
                            <li>If there are no references to the object, the object will be garbage collected.</li>
                        </ul>
                        <pre><code class="language-javascript hljs"><span class="hljs-keyword">const</span> map1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
    map1.set(<span class="hljs-string">'Value'</span>, <span class="hljs-number">1</span>);
    
    <span class="hljs-keyword">const</span> map2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakMap</span>();
    map2.set(<span class="hljs-string">'Value'</span>, <span class="hljs-number">2.3</span>); <span class="hljs-comment">// Throws an error</span>
    
    <span class="hljs-keyword">let</span> obj = {<span class="hljs-attr">name</span>:<span class="hljs-string">"Vivek"</span>};
    <span class="hljs-keyword">const</span> map3 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakMap</span>();
    map3.set(obj, {<span class="hljs-attr">age</span>:<span class="hljs-number">23</span>});</code></pre>
                    </article>
                    <div class="ibpage-article-problems" id="42">


                    </div>
                </section>
                <section class="ibpage-article-header" id="object-destructuring">
                    <h3>43. What is Object Destructuring?</h3>
                    <article class="ibpage-article">
                        <p>Object destructuring is a new way to extract elements from an object or an array.</p>
                        <ul>
                            <li>
                                <strong>Object destructuring: </strong>Before ES6 version:
                            </li>
                        </ul>
                        <pre><code class="language-javascript hljs"><span class="hljs-keyword">const</span> classDetails = {
      <span class="hljs-attr">strength</span>: <span class="hljs-number">78</span>,
      <span class="hljs-attr">benches</span>: <span class="hljs-number">39</span>,
      <span class="hljs-attr">blackBoard</span>:<span class="hljs-number">1</span>
    }
    
    <span class="hljs-keyword">const</span> classStrength = classDetails.strength;
    <span class="hljs-keyword">const</span> classBenches = classDetails.benches;
    <span class="hljs-keyword">const</span> classBlackBoard = classDetails.blackBoard;</code></pre>
                        <p>The same example using object destructuring:</p>
                        <pre><code class="language-javascript hljs"><span class="hljs-keyword">const</span> classDetails = {
      <span class="hljs-attr">strength</span>: <span class="hljs-number">78</span>,
      <span class="hljs-attr">benches</span>: <span class="hljs-number">39</span>,
      <span class="hljs-attr">blackBoard</span>:<span class="hljs-number">1</span>
    }
    
    <span class="hljs-keyword">const</span> {<span class="hljs-attr">strength</span>:classStrength, <span class="hljs-attr">benches</span>:classBenches,<span class="hljs-attr">blackBoard</span>:classBlackBoard} = classDetails;
    
    <span class="hljs-built_in">console</span>.log(classStrength); <span class="hljs-comment">// Outputs 78</span>
    <span class="hljs-built_in">console</span>.log(classBenches); <span class="hljs-comment">// Outputs 39</span>
    <span class="hljs-built_in">console</span>.log(classBlackBoard); <span class="hljs-comment">// Outputs 1</span></code></pre>
                        <p>As one can see, using object destructuring we have extracted all the elements inside an
                            object in one
                            line of code. If we want our new variable to have the same name as the property of an object
                            we can
                            remove the colon:</p>
                        <pre><code class="language-javascript hljs"><span class="hljs-keyword">const</span> {<span class="hljs-attr">strength</span>:strength} = classDetails;
    <span class="hljs-comment">// The above line of code can be written as:</span>
    <span class="hljs-keyword">const</span> {strength} = classDetails;</code></pre>
                        <ul>
                            <li>
                                <strong>Array destructuring: </strong>Before ES6 version:
                            </li>
                        </ul>
                        <pre><code class="language-javascript hljs"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];
    <span class="hljs-keyword">const</span> first = arr[<span class="hljs-number">0</span>];
    <span class="hljs-keyword">const</span> second = arr[<span class="hljs-number">1</span>];
    <span class="hljs-keyword">const</span> third = arr[<span class="hljs-number">2</span>];
    <span class="hljs-keyword">const</span> fourth = arr[<span class="hljs-number">3</span>];</code></pre>
                        <p>The same example using object destructuring:</p>
                        <pre><code class="language-javascript hljs"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];
    <span class="hljs-keyword">const</span> [first,second,third,fourth] = arr;
    <span class="hljs-built_in">console</span>.log(first); <span class="hljs-comment">// Outputs 1</span>
    <span class="hljs-built_in">console</span>.log(second); <span class="hljs-comment">// Outputs 2</span>
    <span class="hljs-built_in">console</span>.log(third); <span class="hljs-comment">// Outputs 3</span>
    <span class="hljs-built_in">console</span>.log(fourth); <span class="hljs-comment">// Outputs 4</span></code></pre>
                    </article>
                    <div class="ibpage-article-problems" id="43">


                    </div>
                </section>
                <section class="ibpage-article-header" id="difference-between-prototypal-and-classical-inheritance">
                    <h3>44. Difference between prototypal and classical inheritance</h3>
                    <article class="ibpage-article">
                        <p>Programers build objects, which are representations of real-time entities, in traditional OO
                            programming. Classes and objects are the two sorts of abstractions. A class is a
                            generalization of
                            an object, whereas an object is an abstraction of an actual thing. A Vehicle, for example,
                            is a
                            specialization of a Car. As a result, automobiles (class) are descended from vehicles
                            (object).</p>
                        <p>Classical inheritance differs from prototypal inheritance in that classical inheritance is
                            confined
                            to classes that inherit from those remaining classes, but prototypal inheritance allows any
                            object
                            to be cloned via an object linking method. Despite going into too many specifics, a
                            prototype
                            essentially serves as a template for those other objects, whether they extend the parent
                            object or
                            not.</p>
                    </article>
                    <div class="ibpage-article-problems" id="44">


                    </div>
                </section>
                <section class="ibpage-article-header" id="temporal-dead-zone">
                    <h3>45. What is a Temporal Dead Zone?</h3>
                    <article class="ibpage-article">
                        <p>Temporal Dead Zone is a behaviour that occurs with variables declared using <strong>let
                            </strong>and
                            <strong>const </strong>keywords. It is a behaviour where we try to access a variable before
                            it is
                            initialized. Examples of temporal dead zone:
                        </p>
                        <pre><code class="language-javascript hljs">x = <span class="hljs-number">23</span>; <span class="hljs-comment">// Gives reference error</span>
    
    <span class="hljs-keyword">let</span> x;
    
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">anotherRandomFunc</span>(<span class="hljs-params"></span>)</span>{
      message = <span class="hljs-string">"Hello"</span>; <span class="hljs-comment">// Throws a reference error</span>
    
      <span class="hljs-keyword">let</span> message;
    }
    anotherRandomFunc();</code></pre>
                        <p>In the code above, both in the global scope and functional scope, we are trying to access
                            variables
                            that have not been declared yet. This is called the <strong>Temporal Dead Zone</strong>.</p>
                    </article>
                    <div class="ibpage-article-problems" id="45">


                    </div>
                </section>
                <section class="ibpage-article-header" id="javascript-design-patterns">
                    <h3>46. What do you mean by JavaScript Design Patterns?</h3>
                    <article class="ibpage-article">
                        <p>JavaScript design patterns are repeatable approaches for errors that arise sometimes when
                            building
                            JavaScript browser applications. They truly assist us in making our code more stable.</p>
                        <p>They are divided mainly into 3 categories&nbsp;</p>
                        <ol>
                            <li>Creational Design Pattern</li>
                            <li>Structural Design Pattern</li>
                            <li>Behavioral Design Pattern.</li>
                        </ol>
                        <ul>
                            <li>
                                <strong>Creational Design Pattern: </strong>The object generation mechanism is addressed
                                by the
                                JavaScript Creational Design Pattern. They aim to make items that are appropriate for a
                                certain
                                scenario.
                            </li>
                            <li>
                                <strong>Structural Design Pattern: </strong>The JavaScript Structural Design Pattern
                                explains
                                how the classes and objects we've generated so far can be combined to construct bigger
                                frameworks. This pattern makes it easier to create relationships between items by
                                defining a
                                straightforward way to do so.
                            </li>
                            <li>
                                <strong>Behavioral Design Pattern: </strong>This design pattern highlights typical
                                patterns of
                                communication between objects in JavaScript. As a result, the communication may be
                                carried out
                                with greater freedom.
                            </li>
                        </ul>
                    </article>
                    <div class="ibpage-article-problems" id="46">


                    </div>
                </section>
                <section class="ibpage-article-header" id="is-javascript-a-pass-by-reference-or-pass-by-value-language">
                    <h3>47. Is JavaScript a pass-by-reference or pass-by-value language?</h3>
                    <article class="ibpage-article">
                        <p>The variable's data is always a reference for objects, hence it's always pass by value. As a
                            result,
                            if you supply an object and alter its members inside the method, the changes continue
                            outside of it.
                            It appears to be pass by reference in this case. However, if you modify the values of the
                            object
                            variable, the change will not last, demonstrating that it is indeed passed by value.</p>
                    </article>
                    <div class="ibpage-article-problems" id="47">


                    </div>
                </section>
                <section class="ibpage-article-header"
                    id="asynch-await-vs-generators-usage-to-acheive-the-same-functionality">
                    <h3>48. Difference between Async/Await and Generators usage to achieve the same functionality.</h3>
                    <article class="ibpage-article">
                        <ul>
                            <li>Generator functions are run by their generator yield by yield which means one output at
                                a time,
                                whereas Async-await functions are executed sequentially one after another.</li>
                            <li>Async/await provides a certain use case for Generators easier to execute.</li>
                            <li>The output result of the Generator function is always value: X, done: Boolean, but the
                                return
                                value of the Async function is always an assurance or throws an error.</li>
                        </ul>
                    </article>
                    <div class="ibpage-article-problems" id="48">


                    </div>
                </section>
                <section class="ibpage-article-header" id="primitive-data-types">
                    <h3>49. What are the primitive data types in JavaScript?</h3>
                    <article class="ibpage-article">
                        <p>A primitive is a data type that isn't composed of other data types. It's only capable of
                            displaying
                            one value at a time. By definition, every primitive is a built-in data type (the compiler
                            must be
                            knowledgeable of them) nevertheless, not all built-in datasets are primitives. In
                            JavaScript, there
                            are 5 different forms of basic data. The following values are available:</p>
                        <ol>
                            <li>Boolean</li>
                            <li>Undefined</li>
                            <li>Null</li>
                            <li>Number</li>
                            <li>String</li>
                        </ol>
                    </article>
                    <div class="ibpage-article-problems" id="49">


                    </div>
                </section>
                <section class="ibpage-article-header" id="role-of-deferred-scripts-in-javascript">
                    <h3>50. What is the role of deferred scripts in JavaScript?</h3>
                    <article class="ibpage-article">
                        <p>The processing of HTML code while the page loads are disabled by nature till the script
                            hasn't
                            halted. Your page will be affected if your network is a bit slow, or if the script is very
                            hefty.
                            When you use Deferred, the script waits for the HTML parser to finish before executing it.
                            This
                            reduces the time it takes for web pages to load, allowing them to appear more quickly.</p>
                    </article>
                    <div class="ibpage-article-problems" id="50">


                    </div>
                </section>
                <section class="ibpage-article-header"
                    id="what-has-to-be-done-in-order-to-put-lexical-scoping-in-javascript">
                    <h3>51. What has to be done in order to put Lexical Scoping into practice?</h3>
                    <article class="ibpage-article">
                        <p>To support lexical scoping, a JavaScript function object's internal state must include not
                            just the
                            function's code but also a reference to the current scope chain.</p>
                    </article>
                    <div class="ibpage-article-problems" id="51">


                    </div>
                </section>
                <section class="ibpage-article-header" id="purpose-of-the-following-javascript-code">
                    <h3>52. What is the purpose of the following JavaScript code?</h3>
                    <article class="ibpage-article">
                        <pre><code class="language-javascript hljs"><span class="hljs-keyword">var</span> scope = <span class="hljs-string">"global scope"</span>;
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">check</span>(<span class="hljs-params"></span>) 
    </span>{
        <span class="hljs-keyword">var</span> scope = <span class="hljs-string">"local scope"</span>; 
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) 
        </span>{ 
             <span class="hljs-keyword">return</span> scope; 
        }
        <span class="hljs-keyword">return</span> f;
    }</code></pre>
                        <p>Every executing function, code block, and script as a whole in JavaScript has a related
                            object known
                            as the Lexical Environment. The preceding code line returns the value in scope.</p>
                    </article>
                    <div class="ibpage-article-problems" id="52">


                    </div>
                </section>

            </div>
        </div>
    </div>
    <script>
        Array.from(document.getElementsByTagName("img")).forEach((elem) => elem.style.display = "none")
        let sidenav = ''
        Array.from(document.getElementsByTagName("h3")).forEach((elem, i) => elem.setAttribute("id", i))
        Array.from(document.getElementsByTagName("h3")).forEach((elem, i) => sidenav += `<a href="#${i}">${elem.innerText}</a>`)
        document.getElementById("side").innerHTML = sidenav
        document.getElementById("btn").addEventListener("click", () => {
            document.getElementsByClassName("sidebar")[0].classList.toggle("show")
        })
        Array.from(document.getElementById("side").getElementsByTagName("a")).forEach((elem) => elem.addEventListener("click", () => document.getElementsByClassName("sidebar")[0].classList.toggle("show")))

        document.getElementsByClassName("main")[0].addEventListener("click",()=>document.getElementsByClassName("sidebar")[0].classList.remove("show"))

    </script>
</body>

</html>